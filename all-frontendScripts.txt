//--- FILE: lang.js ---

(() => {
   // Public state seeds
   window.translations = window.translations || {};
   const rawSeed = window.lang || document.documentElement.dataset.appLang || 'en';

   // Normalize language codes to canonical values used by server
   const normalizeLang = (raw) => {
      if (!raw) return 'en';
      const lower = String(raw).toLowerCase();
      if (lower.startsWith('en')) return 'en';
      if (lower.startsWith('zh')) return 'zh-HK';
      return 'en';
   };

   window.lang = normalizeLang(rawSeed);

   // Safe dot-path lookup: "ns.key.sub"
   const lookup = (obj, path) => {
      if (!obj || !path) return undefined;
      const parts = String(path).split('.');
      let cur = obj;
      for (const p of parts) {
         if (cur && typeof cur === 'object' && Object.prototype.hasOwnProperty.call(cur, p)) {
            cur = cur[p];
         } else {
            return undefined;
         }
      }
      return cur;
   };

   // t: simple sync lookup with fallback
   window.t = function (key, fallback) {
      if (!key) return typeof fallback !== 'undefined' ? fallback : key;
      const v = lookup(window.translations, key);
      if (typeof v === 'string') return v;
      return typeof fallback !== 'undefined' ? fallback : key;
   };

   // ti: lookup + basic interpolation using {var} placeholders
   window.ti = function (key, vars = {}, fallback) {
      const str = window.t(key, fallback);
      if (typeof str !== 'string') return str;
      return str.replace(/\{(\w+)\}/g, (_, name) => {
         return Object.prototype.hasOwnProperty.call(vars, name) ? String(vars[name]) : '';
      });
   };

   // Bounded loader with timeout and guaranteed ready event
   const LOAD_TIMEOUT_MS = 5000;

   const loadTranslations = async (requestedLang = window.lang) => {
      const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
      const id = controller ? setTimeout(() => controller.abort(), LOAD_TIMEOUT_MS) : null;
      try {
         const res = await fetch(`/api/translations?lang=${encodeURIComponent(requestedLang)}`, {
            credentials: 'same-origin',
            signal: controller ? controller.signal : undefined
         });
         if (!res.ok) throw new Error(`Failed to load translations: ${res.status}`);
         const data = await res.json().catch(() => null);
         window.translations = (data && typeof data === 'object') ? data : {};
         // update lang if server returned canonical lang info (optional)
      } catch (err) {
         // Network/errors -> log and fall back to empty translations
         console.error('Translation load error', err);
         window.translations = {};
      } finally {
         if (id) clearTimeout(id);
         // Always notify consumers; they should handle empty translations
         try {
            document.dispatchEvent(new Event('translations:ready'));
         } catch (e) {
            // defensive: older environments may fail to construct Event
            const ev = document.createEvent && document.createEvent('Event');
            if (ev && ev.initEvent) ev.initEvent('translations:ready', true, true);
            try { document.dispatchEvent(ev); } catch (_) { /* ignore */ }
         }
      }
      return window.translations;
   };

   // Initial load
   loadTranslations().catch(() => { /* handled inside */
   });

   // Runtime reload API (used by toggle handlers)
   window.__reloadTranslations = async (newLang) => {
      const normalized = normalizeLang(newLang || window.lang || 'en');
      window.lang = normalized;
      return loadTranslations(normalized);
   };

   // Small helper: expose a promise for consumers that prefer awaiting readiness
   // Usage: await window.__translationsReady;
   if (!window.__translationsReady) {
      window.__translationsReady = new Promise((resolve) => {
         if (window.translations && Object.keys(window.translations).length) return resolve(window.translations);
         const onReady = () => {
            document.removeEventListener('translations:ready', onReady);
            resolve(window.translations);
         };
         document.addEventListener('translations:ready', onReady);
      });
   }
})();
//--- END ---

//--- FILE: main_cust.js ---

document.addEventListener("DOMContentLoaded", () => {
   // ----- Config -----
   const channel = (typeof BroadcastChannel !== "undefined") ? new BroadcastChannel("auth_channel") : null;
   const REFRESH_BUFFER_MS = 2 * 60 * 1000;
   const ACTIVITY_EVENTS = ["click", "mousemove", "keydown", "scroll", "touchstart"];
   const ACTIVITY_REFRESH_THROTTLE_MS = 60 * 1000;
   const CROSS_TAB_WAIT_MS = 120;

   // ----- Safe localStorage wrapper -----
   const safeLocal = {
      get: (key) => {
         try { return localStorage.getItem(key); } catch (e) { return null; }
      },
      set: (key, val) => {
         try {
            if (val == null) localStorage.removeItem(key);
            else localStorage.setItem(key, val);
         } catch (e) { /* ignore */ }
      },
      remove: (key) => {
         try { localStorage.removeItem(key); } catch (e) { /* ignore */ }
      }
   };

   // ----- Token helpers -----
   const decodeTokenSafely = (token) => {
      try { return jwt_decode(token); } catch (e) { return null; }
   };
   const isTokenExpired = (token) => {
      const decoded = decodeTokenSafely(token);
      return !decoded || !decoded.exp || Date.now() >= decoded.exp * 1000;
   };

   // ----- State and timers -----
   let refreshTimeout = null;
   let _refreshInFlight = null;
   let _localWaiters = [];
   let lastActivityRefresh = 0;

   // track modal timer to allow cleanup
   const _timers = {modalTimer: null, swalTimerRefs: new Set()};

   // ----- Storage helpers -----
   const storeAccessToken = (accessToken) => safeLocal.set("accessToken", accessToken);
   const clearAccessToken = () => safeLocal.remove("accessToken");

   // ----- Logout (narrow) -----
   const safeLogout = () => {
      if (window.location.pathname === "/login") return;
      try {
         clearAccessToken();
         // remove other app-specific keys here if needed
         // safeLocal.remove("someOtherKey");
      } catch (e) { /* ignore */ }
      try { channel?.postMessage?.({type: "logout"}); } catch (e) { /* ignore */ }
      window.location.href = "/login";
   };

   // ----- Fetch helpers -----
   const safeFetch = async (url, options = {}, onSuccess = async () => {
   }, expectJson = true) => {
      try {
         const res = await fetch(url, {credentials: "include", ...options});
         const contentType = res.headers.get("content-type") || "";
         const isJson = contentType.includes("application/json");
         if (res.ok && (!expectJson || isJson)) {
            await onSuccess(res);
         } else {
            if (url === "/session" || url === "/t-refresh") {
               if (res.status === 401 || res.status === 403) safeLogout();
               return;
            }
            safeLogout();
         }
      } catch (err) {
         console.error(`Fetch error at ${url}:`, err);
         if (url === "/session" || url === "/t-refresh") return;
         safeLogout();
      }
   };

   const fetchAndHandleTokens = async (url, options = {}) => {
      options.headers = Object.assign({
         "Accept": "application/json",
         "Content-Type": "application/json"
      }, options.headers || {});

      const attempts = 5;
      const baseDelay = 300;

      for (let attempt = 1; attempt <= attempts; attempt++) {
         let didSucceed = false;
         await safeFetch(url, options, async (res) => {
            const contentType = res.headers.get("content-type") || "";
            if (!contentType.includes("application/json")) return;
            const body = await res.json().catch(() => null);
            const {accessToken} = body || {};
            if (!accessToken) return;
            storeAccessToken(accessToken);
            scheduleTokenRefresh(accessToken);
            try { channel?.postMessage?.({type: "token_updated", accessToken}); } catch (e) { /* ignore */ }
            didSucceed = true;
         });

         if (didSucceed) return true;
         const delay = baseDelay * Math.pow(2, attempt - 1);
         await new Promise(r => setTimeout(r, delay));
      }

      safeLogout();
      return false;
   };

   // ----- Single-flight + cross-tab coordination -----
   const _enqueueLocalWaiter = () => new Promise(resolve => _localWaiters.push(resolve));
   const _flushLocalWaiters = (token) => {
      const waiters = _localWaiters.splice(0);
      waiters.forEach(cb => cb(token));
   };

   const refreshAccessToken = async () => {
      const localAccess = safeLocal.get("accessToken");
      if (localAccess && !isTokenExpired(localAccess)) return localAccess;

      if (_refreshInFlight) return await _enqueueLocalWaiter();

      // short cross-tab window to receive token from other tabs
      const crossTabToken = await new Promise(resolve => {
         let resolved = false;
         const onMsg = (ev) => {
            if (ev?.data?.type === "token_updated") {
               resolved = true;
               if (channel?.removeEventListener) channel.removeEventListener("message", onMsg);
               else if (channel) channel.onmessage = null;
               resolve(ev.data.accessToken || null);
            }
         };
         if (channel) {
            if (channel.addEventListener) channel.addEventListener("message", onMsg);
            else channel.onmessage = onMsg;
         }
         setTimeout(() => {
            if (!resolved) {
               if (channel?.removeEventListener) channel.removeEventListener("message", onMsg);
               else if (channel) channel.onmessage = null;
               resolve(null);
            }
         }, CROSS_TAB_WAIT_MS);
      });

      if (crossTabToken) {
         try {
            storeAccessToken(crossTabToken);
            scheduleTokenRefresh(crossTabToken);
         } catch (e) { /* ignore */ }
         _flushLocalWaiters(crossTabToken);
         return crossTabToken;
      }

      _refreshInFlight = (async () => {
         try {
            await fetchAndHandleTokens("/t-refresh", {
               method: "POST",
               headers: {"Accept": "application/json", "Content-Type": "application/json"},
               body: JSON.stringify({})
            });
            return safeLocal.get("accessToken") || null;
         } catch (err) {
            return null;
         }
      })();

      const result = await _refreshInFlight;
      _refreshInFlight = null;
      _flushLocalWaiters(result);
      return result;
   };

   // ----- Activity throttle -----
   const handleUserActivity = () => {
      const now = Date.now();
      if (now - lastActivityRefresh > ACTIVITY_REFRESH_THROTTLE_MS) {
         lastActivityRefresh = now;
         refreshAccessToken().catch(err => console.error("activity refresh failed", err));
      }
   };
   ACTIVITY_EVENTS.forEach(ev => window.addEventListener(ev, handleUserActivity, {passive: true}));

   // ----- BroadcastChannel handler (guarded) -----
   if (channel) {
      const onChannelMessage = (event) => {
         const {type, accessToken} = event.data || {};
         switch (type) {
            case "token_updated":
               try {
                  storeAccessToken(accessToken);
                  scheduleTokenRefresh(accessToken);
               } catch (e) { /* ignore */ }
               _flushLocalWaiters(accessToken);
               break;
            case "logout":
               safeLogout();
               break;
            default:
               break;
         }
      };
      if (channel.addEventListener) channel.addEventListener("message", onChannelMessage);
      else channel.onmessage = onChannelMessage;

      window.addEventListener("beforeunload", () => {
         if (channel?.removeEventListener) channel.removeEventListener("message", onChannelMessage);
         else if (channel) channel.onmessage = null;
      });
   }

   // ----- Keepalive (with timeout + retries) -----
   const KEEPALIVE_URL = "/session/keepalive";
   const LOGOUT_URL = "/logout";
   const KEEPALIVE_TIMEOUT_MS = 8000;
   const MAX_KEEPALIVE_RETRIES = 3;
   const KEEPALIVE_RETRY_BASE_MS = 600;

   const fetchWithTimeout = async (url, opts = {}, timeoutMs = KEEPALIVE_TIMEOUT_MS) => {
      const hasAbort = typeof AbortController !== "undefined";
      const controller = hasAbort ? new AbortController() : null;
      const id = hasAbort ? setTimeout(() => controller.abort(), timeoutMs) : setTimeout(() => {
      }, timeoutMs);
      try {
         if (hasAbort) opts.signal = controller.signal;
         const res = await fetch(url, Object.assign({credentials: "include"}, opts));
         clearTimeout(id);
         return res;
      } catch (err) {
         clearTimeout(id);
         throw err;
      }
   };

   const callKeepaliveOnce = async () => {
      const res = await fetchWithTimeout(KEEPALIVE_URL, {
         method: "POST",
         headers: {"Accept": "application/json"}
      }, KEEPALIVE_TIMEOUT_MS);
      const status = res.status;
      if (status === 200) {
         const body = await res.json().catch(() => null);
         return {ok: true, expiresAt: body?.expiresAt || null, status};
      }
      if (status === 401 || status === 403) return {ok: false, auth: false, status};
      const text = await res.text().catch(() => "");
      return {ok: false, status, text};
   };

   const doKeepalive = async () => {
      for (let attempt = 0; attempt <= MAX_KEEPALIVE_RETRIES; attempt++) {
         try {
            const r = await callKeepaliveOnce();
            if (r.ok) return r;
            if (r.auth === false) return r;
         } catch (err) { /* ignore */ }
         await new Promise(r => setTimeout(r, KEEPALIVE_RETRY_BASE_MS * Math.pow(2, attempt)));
      }
      return {ok: false, retries: true};
   };

   // ----- Countdown helpers for Swal -----
   const updateSwalCountdownToExpiry = (expiresAtIso) => {
      try {
         const htmlContainer = document.querySelector(".swal2-html-container");
         if (!htmlContainer) return;
         let countdownEl = htmlContainer.querySelector("#countdown");
         if (!countdownEl) {
            countdownEl = document.createElement("span");
            countdownEl.id = "countdown";
            htmlContainer.appendChild(countdownEl);
         }
         if (countdownEl._swalTimer) {
            clearInterval(countdownEl._swalTimer);
            countdownEl._swalTimer = null;
         }
         const expiryMs = Date.parse(expiresAtIso);
         if (isNaN(expiryMs)) return;
         const update = () => {
            const remain = Math.max(0, Math.floor((expiryMs - Date.now()) / 1000));
            const mm = Math.floor(remain / 60).toString().padStart(2, "0");
            const ss = (remain % 60).toString().padStart(2, "0");
            countdownEl.textContent = `${mm}:${ss}`;
         };
         update();
         countdownEl._swalTimer = setInterval(update, 1000);
         _timers.swalTimerRefs.add(countdownEl);
      } catch (e) {
         console.debug("updateSwalCountdownToExpiry error", e);
      }
   };

   const keepSessionAliveAndResetCountdown = async () => {
      const confirmBtn = document.querySelector(".swal2-confirm");
      try { if (confirmBtn) confirmBtn.disabled = true; } catch (e) { /* ignore */ }
      try {
         const result = await doKeepalive();
         if (result.auth === false) {
            window.location.href = LOGOUT_URL;
            return false;
         }
         if (result.ok && result.expiresAt) {
            updateSwalCountdownToExpiry(result.expiresAt);
            try { refreshAccessToken(); } catch (e) { /* ignore */ }
            try { if (window.Swal) window.Swal.close(); } catch (e) { /* ignore */ }
            return true;
         }
         const htmlContainer = document.querySelector(".swal2-html-container");
         if (htmlContainer) {
            let errEl = htmlContainer.querySelector(".keepalive-err");
            if (!errEl) {
               errEl = document.createElement("div");
               errEl.className = "keepalive-err";
               errEl.style.color = "#c00";
               errEl.style.marginTop = "8px";
               htmlContainer.appendChild(errEl);
            }
            errEl.textContent = "Unable to extend session. Please try again.";
         }
         return false;
      } finally {
         try { if (confirmBtn) confirmBtn.disabled = false; } catch (e) { /* ignore */ }
      }
   };

   // ----- Session Extend Modal -----
   const showSessionExtendModal = (expiryTimeMs) => {
      if (typeof Swal === "undefined") return;
      _timers.modalTimer && clearTimeout(_timers.modalTimer);
      const expiryIso = new Date(expiryTimeMs).toISOString();
      _timers.modalTimer = setTimeout(() => { /* placeholder in case scheduled separately */
      }, 0);
      Swal.fire({
         title: "Session Expiring Soon",
         html: `Do you want to stay signed in?<br><br>Session expires in <span id="countdown"></span>`,
         icon: "warning",
         showCancelButton: true,
         confirmButtonText: "Yes, keep me signed in",
         cancelButtonText: "Log me out",
         allowOutsideClick: false,
         allowEscapeKey: false,
         didOpen: () => {
            const countdownSpan = Swal.getHtmlContainer().querySelector("#countdown");
            const updateCountdown = () => {
               const remaining = Math.max(0, Math.floor((expiryTimeMs - Date.now()) / 1000));
               const min = Math.floor(remaining / 60);
               const sec = remaining % 60;
               countdownSpan.textContent = `${min}:${sec.toString().padStart(2, "0")}`;
               if (remaining <= 0) {
                  clearInterval(timer);
                  Swal.close();
                  safeLogout();
               }
            };
            updateCountdown();
            const timer = setInterval(updateCountdown, 1000);
            _timers.swalTimerRefs.add({clear: () => clearInterval(timer)});
         }
      }).then((result) => {
         if (result.isConfirmed) keepSessionAliveAndResetCountdown();
         else safeLogout();
      });
   };

   // ----- Language toggle -----
   const langBtn = document.getElementById("changeLang");
   if (langBtn) {
      langBtn.addEventListener("click", async (e) => {
         e.preventDefault();
         await safeFetch("/toggle-language", {method: "POST"}, () => {
            window.location.href = window.location.pathname;
         }, true);
      });
   }

   // ----- scheduleTokenRefresh (schedules UI modal and background refresh) -----
   const scheduleTokenRefresh = (token) => {
      try {
         if (refreshTimeout) {
            clearTimeout(refreshTimeout);
            refreshTimeout = null;
         }
         if (_timers.modalTimer) {
            clearTimeout(_timers.modalTimer);
            _timers.modalTimer = null;
         }
      } catch (e) { /* ignore */ }

      const decoded = decodeTokenSafely(token);
      if (!decoded || !decoded.exp) return;

      const expiryMs = decoded.exp * 1000;
      const now = Date.now();
      const timeUntilExpiry = Math.max(0, expiryMs - now);

      // modal lead time (UX)
      const modalLeadTime = 2 * 60 * 1000;
      const modalDelay = Math.max(timeUntilExpiry - modalLeadTime, 0);
      _timers.modalTimer = setTimeout(() => {
         try { showSessionExtendModal(expiryMs); } catch (e) { console.debug("showSessionExtendModal error", e); }
      }, modalDelay);

      // schedule background refresh
      const refreshDelay = Math.max(timeUntilExpiry - REFRESH_BUFFER_MS, 0);
      refreshTimeout = setTimeout(() => {
         refreshAccessToken().catch(err => console.error("background refresh failed", err));
      }, refreshDelay);
   };

   // ----- Rehydrate session on load (unless on login) -----
   if (!window.location.pathname.startsWith("/login")) {
      setTimeout(async () => {
         await fetchAndHandleTokens("/session", {
            method: "POST",
            headers: {"Accept": "application/json", "Content-Type": "application/json"},
            body: JSON.stringify({})
         });
      }, 600);
   }

   // ----- Expose debug helpers -----
   window._mgmtSession = {
      showSessionExtendModal,
      refreshAccessToken,
      keepSessionAliveAndResetCountdown,
      _debug_getLocalToken: () => safeLocal.get("accessToken")
   };

   // ----- Page-specific initializers -----
   if (window.location.pathname === "/groups") {
      try { if (typeof initGroupManagement === "function") initGroupManagement(); } catch (e) { console.debug("initGroupManagement missing", e); }
   }

   // === deterministic, idempotent UI bootstrap (paste after page-specific initializers) ===
   if (!window.__appBootstrapped) {
      window.__appBootstrapped = true;

      const destroyAllTables = () => {
         try {
            if (window.jQuery && window.jQuery.fn && window.jQuery.fn.dataTable) {
               const $ = window.jQuery;
               document.querySelectorAll('.js-datatable').forEach(el => {
                  try {
                     if ($.fn.dataTable.isDataTable(el)) {
                        $(el).DataTable().destroy();
                        try { $(el).empty(); } catch (_) {}
                        console.debug('destroyed DataTable', el);
                     }
                  } catch (e) { console.warn('destroy DataTable error', e); }
               });
            }
         } catch (e) { console.warn('destroy DataTables outer', e); }

         try {
            document.querySelectorAll('.js-tabulator').forEach(el => {
               try {
                  if (el._tabulatorInstance && typeof el._tabulatorInstance.destroy === 'function') {
                     el._tabulatorInstance.destroy();
                     el._tabulatorInstance = null;
                     console.debug('destroyed Tabulator', el);
                  }
               } catch (e) { console.warn('destroy Tabulator error', e); }
            });
         } catch (e) { console.warn('destroy Tabulator outer', e); }
      };

      const initDataTables = () => {
         if (!window.jQuery || !window.jQuery.fn || !window.jQuery.fn.DataTable) return;
         const $ = window.jQuery;
         document.querySelectorAll('.js-datatable').forEach(el => {
            try {
               try {
                  if ($.fn.dataTable.isDataTable(el)) {
                     $(el).DataTable().destroy();
                     $(el).empty();
                  }
               } catch (_) {}
               $(el).DataTable({
                  language: (window.translations && window.translations.datatables) || {},
                  dom: '<"top"i>rt<"bottom"lp><"clear">'
               });
               console.debug('init DataTable', el);
            } catch (e) { console.error('init DataTable error', e); }
         });
      };

      const initTabulator = () => {
         if (!window.Tabulator) return;
         document.querySelectorAll('.js-tabulator').forEach(el => {
            try {
               try {
                  if (el._tabulatorInstance && typeof el._tabulatorInstance.destroy === 'function') {
                     el._tabulatorInstance.destroy();
                     el._tabulatorInstance = null;
                  }
               } catch (_) {}
               const tabLocale = (window.translations && window.translations.tabulator) || {};
               let per = {};
               try { per = el.dataset && el.dataset.tabOptions ? JSON.parse(el.dataset.tabOptions) : {}; } catch (e) { per = {}; }
               const opts = Object.assign({}, per, {locale: window.lang, langs: {[window.lang]: tabLocale}});
               el._tabulatorInstance = new Tabulator(el, opts);
               console.debug('init Tabulator', el);
            } catch (e) { console.error('init Tabulator error', e); }
         });
      };

      const reinitAll = () => {
         try {
            destroyAllTables();
            setTimeout(() => {
               initDataTables();
               initTabulator();
            }, 40);
         } catch (e) { console.error('reinitAll error', e); }
      };

      const startWhenReady = () => {
         if (window.translations && Object.keys(window.translations).length) {
            reinitAll();
         } else {
            const onReady = () => {
               document.removeEventListener('translations:ready', onReady);
               reinitAll();
            };
            document.addEventListener('translations:ready', onReady);
            // fallback: guarded attempt after timeout
            setTimeout(() => {
               if (!(window.translations && Object.keys(window.translations).length)) {
                  console.warn('translations:ready did not fire in time, performing guarded reinit');
               }
               reinitAll();
            }, 5000);
         }
      };

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
         setTimeout(startWhenReady, 20);
      } else {
         document.addEventListener('DOMContentLoaded', () => setTimeout(startWhenReady, 20), {once: true});
      }

      if (!window.__translationsReloadHandlerAdded) {
         window.__translationsReloadHandlerAdded = true;
         document.addEventListener('translations:ready', () => {
            console.debug('translations:ready detected -> reinitAll');
            reinitAll();
         });
      }
   } else {
      console.debug('app bootstrap skipped (already bootstrapped)');
   }
// === end deterministic bootstrap ===

   // ----- Cleanup on unload -----
   const safeClearTimers = () => {
      if (refreshTimeout) {
         clearTimeout(refreshTimeout);
         refreshTimeout = null;
      }
      if (_timers.modalTimer) {
         clearTimeout(_timers.modalTimer);
         _timers.modalTimer = null;
      }
      for (const ref of Array.from(_timers.swalTimerRefs)) {
         try { if (typeof ref === "object" && typeof ref.clear === "function") ref.clear(); else if (ref._swalTimer) clearInterval(ref._swalTimer); } catch (e) {}
         _timers.swalTimerRefs.delete(ref);
      }
   };
   window.addEventListener("beforeunload", safeClearTimers);
});
//--- END ---

//--- FILE: mgmt_category.js ---

function updateTabulatorColumnTitles(table, titleMap) {
   try {
      if (!table || typeof table.getColumns !== "function") return;
      table.getColumns().forEach(col => {
         try {
            const field = col.getField();
            if (!field) return;
            const newTitle = titleMap[field];
            if (typeof newTitle === "string" && newTitle.length > 0) col.updateDefinition({title: newTitle});
         } catch (e) {
         }
      });
      try {
         table.redraw(true);
      } catch (e) {
         try {
            table.replaceData();
         } catch (e2) {
         }
      }
   } catch (e) {
      console.warn("updateTabulatorColumnTitles failed", e);
   }
}

document.addEventListener("DOMContentLoaded", () => {
   const isChinese = window.lang === "zh-HK";
   let currentKeyword = "";

   const getCategoryColumns = () => [
      {
         title: "",
         field: "action",
         hozAlign: "center",
         headerSort: false,
         width: 75,
         formatter: () => `
        <div class="icon-wrapper text-center">
          <img src="/assets/images/icons/trash.svg" class="trash-icon" title="${window.t("#category.delete")}">
          <img src="/assets/images/icons/edit.svg" class="edit-icon" title="${window.t("#category.edit")}">
        </div>`,
         cellClick: (e, cell) => {
            const rowData = cell.getRow().getData();
            const target = e.target;
            if (target.classList.contains("edit-icon")) return handleEdit(rowData);
            if (target.classList.contains("trash-icon")) return handleDelete(rowData, cell.getRow());
         }
      },
      {
         title: isChinese ? window.t("#category.name_c") : window.t("#category.name_e"),
         field: isChinese ? "name_c" : "name_e",
         headerSort: true
      },
      {
         title: isChinese ? window.t("#category.desc_c") : window.t("#category.desc_e"),
         field: isChinese ? "desc_c" : "desc_e",
         headerSort: true
      },
      {
         title: window.t("#category.types"),
         field: "type",
         hozAlign: "left",
         formatter: cell => {
            const val = cell.getValue();
            const types = Array.isArray(val) ? val : (typeof val === "string" ? val.split(",").map(t => t.trim()).filter(Boolean) : []);
            return types.map(type => `<span class="badge bg-primary text-white me-1 mb-1 px-2 py-1">${window.t(type)}</span>`).join("");
         }
      }
   ];

   const categoryTableEl = document.getElementById("categoryTable");
   const modalEl = document.getElementById("categoryModal");
   const modal = new bootstrap.Modal(modalEl, {backdrop: 'static', keyboard: false});

   const searchEl = document.getElementById("categorySearch");
   const addBtn = document.getElementById("btnAddCategory");
   const addBtnWrapper = document.getElementById("btnAddCategoryWrapper");

   const nameInput = document.getElementById("editCategoryName");
   const nameInputC = document.getElementById("editCategoryName_c");
   const idInput = document.getElementById("editCategoryId");
   const confirmBtn = document.getElementById("confirmEditCategory");
   const descriptionInput = document.getElementById("editCategoryDescription");
   const descriptionInputC = document.getElementById("editCategoryDescription_c");
   const isActiveInput = document.getElementById("editCategoryActive");
   const typeSelect = $("#editCategoryType");

   let select2ReadyResolve;
   const select2Ready = new Promise(r => (select2ReadyResolve = r));

   const openModal = (data = {}) => {
      idInput.value = data.category_id || "";
      nameInput.value = data.name_e || "";
      nameInputC.value = data.name_c || "";
      descriptionInput.value = data.desc_e || "";
      descriptionInputC.value = data.desc_c || "";
      isActiveInput.checked = data.is_active !== false;
      const types = Array.isArray(data.type) ? data.type : (typeof data.type === "string" ? data.type.split(",").map(t => t.trim()).filter(Boolean) : []);
      select2Ready.then(() => {
         types.forEach(v => {
            if (!typeSelect.find(`option[value="${v}"]`).length) typeSelect.append(new Option(v, v, false, false));
         });
         typeSelect.val(types).trigger("change");
      });
      modalEl.querySelector("#categoryModalLabel").textContent = data.category_id ? window.t("#category.edit") : window.t("#category.add");
      modal.show();
   };

   const loadSelect2ForCategory = () => {
      typeSelect.select2({
         placeholder: window.t("#category.type_placeholder"),
         allowClear: true,
         tags: true,
         width: "100%",
         data: [
            {id: "general", text: window.t("general")},
            {id: "library", text: window.t("library")},
            {id: "course", text: window.t("course")},
            {id: "lesson", text: window.t("lesson")},
            {id: "material", text: window.t("material")},
            {id: "quiz", text: window.t("quiz")}
         ]
      });
      select2ReadyResolve && select2ReadyResolve();
   };
   loadSelect2ForCategory();

   const handleEdit = rowData => openModal({
      ...rowData,
      type: Array.isArray(rowData.type) ? rowData.type : (typeof rowData.type === "string" ? rowData.type.split(",").map(t => t.trim()).filter(Boolean) : [])
   });

   const handleDelete = (rowData, row) => {
      Swal.fire({
         title: window.t("#category.delete_confirm"),
         icon: "warning",
         showCancelButton: true,
         confirmButtonText: window.t("#category.yes_delete"),
         cancelButtonText: window.t("#category.cancel")
      }).then(async result => {
         if (!result.isConfirmed) return;
         try {
            const res = await fetch(`/category-mgmt/api/categories/${rowData.category_id}`, {method: "DELETE"});
            const resultJson = await res.json();
            if (resultJson.success) {
               row.delete();
               Swal.fire({
                  icon: "success",
                  title: window.t("#category.success"),
                  text: String(rowData.name_e) + " " + window.ti("#category.deleted")
               });
            } else {
               Swal.fire({
                  icon: "error",
                  title: window.t("#category.delete_failed"),
                  text: resultJson.error || window.t("#category.delete_failed")
               });
            }
         } catch (err) {
            Swal.fire({icon: "error", title: window.t("#category.error"), text: err.message});
         }
      });
   };

   const applyRowStyle = row => {
      const el = row.getElement();
      el.style.removeProperty("opacity");
      const data = row.getData();
      el.style.opacity = data.is_active ? "1" : "0.55";
   };

   const table = new Tabulator(categoryTableEl, {
      ajaxURL: "/category-mgmt/api/categories",
      ajaxConfig: "GET",
      layout: "fitDataStretch",
      pagination: true,
      paginationMode: "remote",
      paginationSize: 10,
      paginationSizeSelector: [10, 25, 50, 100, true],
      paginationButtonCount: 4,
      placeholder: window.t("#category.no_categories"),
      index: "category_id",
      locale: window.lang,
      langs: {
         [window.lang]: {
            pagination: {
               first: window.t ? window.t("pagination.first") : "First",
               last: window.t ? window.t("pagination.last") : "Last",
               prev: window.t ? window.t("pagination.prev") : "Prev",
               next: window.t ? window.t("pagination.next") : "Next",
               page_size: window.t ? window.t("pagination.page_size") : "Page size"
            }
         }
      },
      columns: getCategoryColumns(),
      rowFormatter: applyRowStyle,
      paginationDataSent: {page: "page", size: "size"},
      ajaxURLGenerator: (url, config, params) => {
         const qp = new URLSearchParams();
         qp.set("page", params.page);
         qp.set("size", params.size);
         if (typeof currentKeyword === "string" && currentKeyword.trim() !== "") qp.set("keyword", currentKeyword.trim());
         if (Array.isArray(params.sorters) && params.sorters.length) qp.set("sorters", JSON.stringify(params.sorters));
         if (Array.isArray(params.filters) && params.filters.length) qp.set("filters", JSON.stringify(params.filters));
         return `${url}?${qp.toString()}`;
      },
      ajaxResponse: (url, params, response) => {
         const currentPage = response.page ?? params.page;
         const lastPage = response.last_page ?? Math.max(1, Math.ceil((response.total ?? 0) / (params.size || 1)));
         return {
            data: Array.isArray(response.data) ? response.data : [],
            page: currentPage,
            last_page: lastPage,
            total: Number(response.total ?? 0)
         };
      }
   });

   window.categoryTable = table;

   table.on("tableBuilt", () => {
      try {
         const footer = categoryTableEl.querySelector(".tabulator-footer");
         if (!footer) return;
         if (!footer.querySelector(".tabulator-footer-left")) {
            const paginationControls = footer.querySelector(".tabulator-paginator");
            const leftDiv = document.createElement("div");
            leftDiv.className = "tabulator-footer-left d-flex align-items-center";
            const rightDiv = document.createElement("div");
            rightDiv.className = "tabulator-footer-right d-flex align-items-center";
            if (paginationControls) rightDiv.appendChild(paginationControls);
            if (addBtnWrapper) leftDiv.appendChild(addBtnWrapper);
            footer.innerHTML = "";
            footer.appendChild(leftDiv);
            footer.appendChild(rightDiv);
         } else {
            const left = footer.querySelector(".tabulator-footer-left");
            if (left && addBtnWrapper && !left.contains(addBtnWrapper)) left.insertBefore(addBtnWrapper, left.firstChild);
         }

         const titleMap = {
            [isChinese ? "name_c" : "name_e"]: isChinese ? window.t("#category.name_c") : window.t("#category.name_e"),
            [isChinese ? "desc_c" : "desc_e"]: isChinese ? window.t("#category.desc_c") : window.t("#category.desc_e"),
            type: window.t("#category.types")
         };
         if (typeof updateTabulatorColumnTitles === "function") updateTabulatorColumnTitles(table, titleMap);

         try {
            table.setLocale(window.lang);
         } catch (e) {
         }
         try {
            table.options.placeholder = window.t("#category.no_categories");
         } catch (e) {
         }

         translatePagerSizeTexts("#categoryTable");
         // short retry to catch quick re-renders
         setTimeout(() => translatePagerSizeTexts("#categoryTable"), 120);
      } catch (err) {
         console.warn("category tableBuilt handler failed", err);
      }
   });

   // Minimal repair: if select lacks options, build them; otherwise translate labels only
   (function repairPageSizeSelect() {
      const PAGE_SIZES = [10, 25, 50, 100, true];
      const tx = k => (typeof window.t === "function" ? window.t(k) : k);

      function ensure() {
         const sel = document.querySelector("#categoryTable .tabulator-footer select.tabulator-page-size")
            || document.querySelector("#categoryTable .tabulator-footer select");
         if (!sel) return false;
         if (sel.options && sel.options.length > 0) {
            const allText = (tx("pagination.all") && tx("pagination.all") !== "pagination.all") ? tx("pagination.all") : tx("pagination.page_size");
            Array.from(sel.options).forEach(opt => {
               const v = String(opt.value || "").trim().toLowerCase();
               if (v === "" || v === "all" || v === "true" || /(all)/i.test(opt.text || "")) opt.text = allText;
               else {
                  const n = Number(v);
                  if (Number.isFinite(n)) opt.text = String(n);
               }
            });
            sel.title = tx("pagination.page_size");
            sel.setAttribute("aria-label", tx("pagination.page_size"));
            return true;
         }
         Array.from(sel.childNodes).forEach(n => {
            if (n.nodeType !== 1 || n.tagName.toLowerCase() !== "option") sel.removeChild(n);
         });
         const prev = sel.value;
         PAGE_SIZES.forEach(ps => {
            const opt = document.createElement("option");
            if (ps === true) {
               opt.value = "";
               opt.text = (tx("pagination.all") && tx("pagination.all") !== "pagination.all") ? tx("pagination.all") : tx("pagination.page_size");
            } else {
               opt.value = String(ps);
               opt.text = String(ps);
            }
            sel.appendChild(opt);
         });
         try {
            if (prev != null && Array.from(sel.options).some(o => o.value === prev)) sel.value = prev;
         } catch (e) {
         }
         sel.title = tx("pagination.page_size");
         sel.setAttribute("aria-label", tx("pagination.page_size"));
         sel.dispatchEvent(new Event("change", {bubbles: true}));
         return true;
      }

      try {
         ensure();
      } catch (_) {
      }
      setTimeout(() => {
         try {
            ensure();
         } catch (_) {
         }
      }, 120);
      document.addEventListener("translations:ready", () => setTimeout(() => {
         try {
            ensure();
         } catch (_) {
         }
      }, 80));
   })();

   // Translate pager buttons and label (safe, idempotent)
   function translatePagerSizeTexts(tableSelector = "#categoryTable") {
      const tx = k => (typeof window.t === "function" ? window.t(k) : k);
      try {
         const tableEl = document.querySelector(tableSelector);
         if (!tableEl) return;
         const footer = tableEl.querySelector(".tabulator-footer");
         if (!footer) return;
         const paginator = footer.querySelector(".tabulator-paginator") || footer;

         [
            {sel: '[data-page="first"]', key: "pagination.first"},
            {sel: '[data-page="prev"]', key: "pagination.prev"},
            {sel: '[data-page="next"]', key: "pagination.next"},
            {sel: '[data-page="last"]', key: "pagination.last"}
         ].forEach(m => {
            const btn = paginator.querySelector(m.sel) || paginator.querySelector(`button[aria-label*="${m.key.split('.').pop()}"]`);
            if (!btn) return;
            const v = tx(m.key);
            if ((btn.textContent || "").trim() !== v) btn.textContent = v;
            btn.title = v;
            btn.setAttribute("aria-label", v);
         });

         const sizeLabel = paginator.querySelector(".tabulator-page-size-text, .tabulator-page-size-label, label");
         if (sizeLabel) {
            const v = tx("pagination.page_size");
            if ((sizeLabel.textContent || "").trim() !== v) sizeLabel.textContent = v;
         }
         const sizeSelect = paginator.querySelector("select.tabulator-page-size, select");
         if (sizeSelect) {
            const allText = (tx("pagination.all") && tx("pagination.all") !== "pagination.all") ? tx("pagination.all") : tx("pagination.page_size");
            Array.from(sizeSelect.options || []).forEach(opt => {
               const val = String(opt.value || "").trim().toLowerCase();
               if (val === "" || val === "all" || val === "true" || /(all)/i.test(opt.text || "")) {
                  if (opt.text !== allText) opt.text = allText;
               } else {
                  const n = Number(val);
                  if (Number.isFinite(n) && (opt.text.trim() !== String(n))) opt.text = String(n);
               }
            });
            const label = tx("pagination.page_size");
            if ((sizeSelect.title || "") !== label) sizeSelect.title = label;
            if ((sizeSelect.getAttribute("aria-label") || "") !== label) sizeSelect.setAttribute("aria-label", label);
         }
      } catch (e) {
         console.warn("translatePagerSizeTexts failed", e);
      }
   }

   // schedule translator runs
   (function paginatorTranslatorScheduler() {
      let timer = 0;

      function scheduleRun(delay = 60) {
         clearTimeout(timer);
         timer = setTimeout(() => translatePagerSizeTexts("#categoryTable"), delay);
      }

      try {
         if (window.categoryTable && typeof window.categoryTable.on === "function") window.categoryTable.on("tableBuilt", () => scheduleRun(80));
      } catch (e) {
      }
      document.addEventListener("translations:ready", () => scheduleRun(120));
      document.addEventListener("DOMContentLoaded", () => scheduleRun(160));
      window.applyCategoryTranslations = () => scheduleRun(0);
   })();

   document.getElementById("btnAddCategoryWrapper").style.display = "block";
   addBtn?.addEventListener("click", () => openModal());

   searchEl?.addEventListener("input", function () {
      currentKeyword = this.value.trim().toLowerCase();
      table.setPage(1);
   });

   confirmBtn?.addEventListener("click", async () => {
      const selectedTypes = $("#editCategoryType").val();
      const typeString = Array.isArray(selectedTypes) ? selectedTypes.join(",") : "";
      const payload = {
         id: idInput.value,
         name_e: nameInput.value.trim(),
         name_c: nameInputC.value.trim(),
         type: typeString,
         desc_e: descriptionInput.value.trim(),
         desc_c: descriptionInputC.value.trim(),
         is_active: isActiveInput.checked
      };
      if (!payload.name_e) return Swal.fire({
         icon: "warning",
         title: window.t("#category.missing_fields"),
         text: window.t("#category.name_required")
      });
      try {
         const method = payload.id ? "PUT" : "POST";
         const url = payload.id ? `/category-mgmt/api/categories/${payload.id}` : `/category-mgmt/api/categories`;
         const res = await fetch(url, {
            method,
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(payload)
         });
         const result = await res.json();
         if (!result.success) return Swal.fire({
            icon: "error",
            title: window.t("#category.save_failed"),
            text: result.error || window.t("#category.save_failed")
         });
         const categoryId = payload.id || result.data?.category_id || "";
         const updatedRow = {
            category_id: categoryId,
            name_e: payload.name_e,
            name_c: payload.name_c,
            type: payload.type,
            desc_e: payload.desc_e,
            desc_c: payload.desc_c,
            is_active: payload.is_active
         };
         if (!payload.id) table.addData([updatedRow], true); else table.updateOrAddData([updatedRow]);
         const row = table.getRow(categoryId);
         if (row) {
            applyRowStyle(row);
            row.getElement().classList.add("highlight");
            setTimeout(() => row.getElement().classList.remove("highlight"), 1500);
         }
         modal.hide();
         Swal.fire({
            icon: "success",
            title: window.t("#category.success"),
            text: window.ti("#category.saved", {name_e: payload.name_e})
         });
      } catch (err) {
         Swal.fire({icon: "error", title: window.t("#category.error"), text: err.message});
      }
   });

});
//--- END ---

//--- FILE: mgmt_content.js ---

(() => {
   'use strict';

   document.addEventListener('DOMContentLoaded', () => {
      // Config / state
      const isChinese = (typeof lang !== 'undefined' && lang === 'zh-HK');
      let quillE = null, quillC = null;
      let tempUploadToken = null, tempUploadFilename = null;
      let currentKeyword = '';
      window.currentContentId = null;

      // PDF width gate (promise-based)
      if (!window.__pdfMeasurePromise) {
         window.__pdfMeasuredWidth = 0;
         window.__pdfMeasureResolved = false;
         window.__pdfMeasureQueue = [];
         window.__resolvePdfMeasure = null;
         window.__pdfMeasurePromise = new Promise((res) => {
            window.__resolvePdfMeasure = (w) => {
               try {
                  window.__pdfMeasuredWidth = Math.max(100, Math.floor(w || 600));
                  window.__pdfMeasureResolved = true;
                  res(window.__pdfMeasuredWidth);
                  // flush any queued callbacks
                  const q = window.__pdfMeasureQueue.splice(0);
                  q.forEach(fn => {
                     try { fn(); } catch (e) { console.warn('pdf queue item failed', e); }
                  });
               } catch (e) { res(window.__pdfMeasuredWidth); }
            };
         });
      }

      const el = (id) => document.getElementById(id);
      const contentTableEl = el('contentTable');
      const btnAddWrapper = el('btnAddContentWrapper');
      const uploadTriggerBtn = el('uploadTriggerBtn');
      const selectedFileNameEl = el('selectedFileName');

      if (btnAddWrapper) btnAddWrapper.style.display = 'inline-flex';

      // Utility: generate temp token
      const generateTempToken = (opts = {}) => {
         const suffix = opts.suffix || `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
         if (opts.keepContentId && window.currentContentId) return String(window.currentContentId);
         return `tmp-${suffix}`;
      };

      // Upload helper (XHR with progress)
      const uploadFileWithProgress = (file, token, onProgress = () => {
      }, options = {}) => {
         return new Promise((resolve, reject) => {
            if (!file) return reject(new Error('No file provided'));
            if (!token) return reject(new Error('Missing upload token'));

            const url = `/content-mgmt/api/contents/temp-upload?token=${encodeURIComponent(token)}`;
            const xhr = new XMLHttpRequest();
            uploadFileWithProgress._currentXhr = xhr;

            let finished = false;
            const cleanup = () => {
               if (uploadFileWithProgress._currentXhr === xhr) uploadFileWithProgress._currentXhr = null;
            };

            const done = (err, text) => {
               if (finished) return;
               finished = true;
               cleanup();
               if (err) return reject(err);
               try {
                  const parsed = text ? JSON.parse(text) : null;
                  return resolve(parsed);
               } catch (e) {
                  return reject(new Error('Invalid JSON response from upload'));
               }
            };

            try {
               xhr.open('POST', url, true);
               if (typeof options.timeoutMs === 'number' && options.timeoutMs > 0) xhr.timeout = options.timeoutMs;
               xhr.responseType = 'text';
            } catch (e) {
               cleanup();
               return reject(new Error(`Failed to open upload XHR: ${String(e)}`));
            }

            try {
               xhr.upload.addEventListener('progress', (ev) => {
                  try {
                     if (ev.lengthComputable) {
                        const pct = Math.round((ev.loaded / ev.total) * 100);
                        onProgress(pct, ev.loaded, ev.total);
                     } else {
                        onProgress(null, ev.loaded, null);
                     }
                  } catch (e) { /* ignore */ }
               });
            } catch (e) { /* ignore */ }

            xhr.addEventListener('load', () => {
               const status = xhr.status || 0;
               const text = xhr.responseText || '';
               if (status >= 200 && status < 300) return done(null, text);
               try {
                  const maybe = text ? JSON.parse(text) : null;
                  const msg = maybe && (maybe.error || maybe.message) ? (maybe.error || maybe.message) : `Upload failed (${status})`;
                  return done(new Error(msg));
               } catch {
                  return done(new Error(`Upload failed (${status})`));
               }
            });
            xhr.addEventListener('error', () => done(new Error('Network error during upload')));
            xhr.addEventListener('abort', () => done(new Error('Upload cancelled')));
            xhr.addEventListener('timeout', () => done(new Error('Upload timeout')));

            try {
               const form = new FormData();
               form.append('uploadedFile', file, file.name);
               xhr.send(form);
            } catch (e) {
               cleanup();
               return reject(new Error(`Failed to send upload: ${String(e)}`));
            }
         });
      };

      const cancelCurrentUpload = () => {
         try {
            const cur = uploadFileWithProgress._currentXhr;
            if (cur) try { cur.abort(); } catch (e) { /* ignore */ }
         } finally { try { uploadFileWithProgress._currentXhr = null; } catch (e) { /* ignore */ } }
      };

      const showToast = (msg, type = 'info', opts = {}) => {
         try {
            Swal.fire(Object.assign({
               icon: type === 'error' ? 'error' : (type === 'success' ? 'success' : (type === 'info' ? 'info' : 'warning')),
               title: msg,
               showConfirmButton: false,
               timer: 2500,
               toast: false,
               position: 'center'
            }, opts));
         } catch (e) {
            console[type === 'error' ? 'error' : 'log']('Toast:', msg, e);
         }
      };

      // Tabulator table
      const table = new Tabulator(contentTableEl, {
         ajaxURL: '/content-mgmt/api/contents',
         ajaxConfig: 'GET',
         layout: 'fitDataStretch',
         pagination: true,
         paginationMode: 'remote',
         paginationSize: 10,
         paginationSizeSelector: [10, 25, 50, 100, true],
         paginationButtonCount: 4,
         placeholder: window.t ? window.t('contentmgr.no_data') : 'No data',
         index: 'content_id',
         locale: window.lang,
         langs: {
            [window.lang]: {
               pagination: {
                  first: window.t ? window.t('pagination.first') : 'First',
                  last: window.t ? window.t('pagination.last') : 'Last',
                  prev: window.t ? window.t('pagination.prev') : 'Prev',
                  next: window.t ? window.t('pagination.next') : 'Next',
                  page_size: window.t ? window.t('pagination.page_size') : 'Page size'
               }
            }
         },
         columns: [
            {
               title: '',
               field: 'action',
               hozAlign: 'center',
               headerSort: false,
               resizable: false,
               width: 70,
               formatter: (cell) => {
                  const row = cell.getRow().getData();
                  const isPublished = !!row.is_publish;
                  const canDelete = !isPublished;
                  const editDisabledClass = isPublished ? 'disabled-icon' : '';
                  const deleteDisabledClass = canDelete ? '' : 'disabled-icon disabled-delete';
                  const idEnc = encodeURIComponent(row.content_id);
                  return `<div class="icon-wrapper" data-content-id="${idEnc}">
                      <img src="/assets/images/icons/trash.svg" class="trash-icon ${deleteDisabledClass}" data-action="delete" alt="delete" title="${window.t ? window.t('contentmgr.delete') : 'Delete'}">
                      <img src="/assets/images/icons/edit.svg" class="edit-icon ${editDisabledClass}" data-action="edit" alt="edit" title="${window.t ? window.t('contentmgr.edit') : 'Edit'}">
                    </div>`;
               }
            },
            {
               title: '',
               field: 'action2',
               hozAlign: 'center',
               headerSort: false,
               resizable: false,
               width: 70,
               formatter: (cell) => {
                  const row = cell.getRow().getData();
                  const isPublished = !!row.is_publish;
                  const publishIcon = isPublished ? 'unpublish.svg' : 'publish.svg';
                  const publishTitle = isPublished ? (window.t ? window.t('contentmgr.unpublish') : 'Unpublish') : (window.t ? window.t('contentmgr.publish') : 'Publish');
                  const idEnc = encodeURIComponent(row.content_id);
                  return `<div class="icon-wrapper action2-cell" data-content-id="${idEnc}">
                      <img src="/assets/images/icons/${publishIcon}" class="publish-toggle-icon" data-action="toggle-publish" data-published="${isPublished}" data-inuse="${!!row.in_use}" alt="${publishTitle}" title="${publishTitle}">
                      <img src="/assets/images/icons/preview.svg" class="preview-icon" data-action="preview" alt="preview" title="${window.t ? window.t('contentmgr.preview') : 'Preview'}">
                    </div>`;
               }
            },
            {title: 'ID', field: 'content_id', headerSort: true, resizable: false},
            {
               title: window.t ? window.t('contentmgr.type') : 'Type',
               field: 'type',
               headerSort: true,
               formatter: (cell) => {
                  let type = cell.getValue();
                  if (Array.isArray(type)) type = type.find(t => /pdf|html|video/.test(String(t))) || type[0];
                  if (typeof type === 'object' && type !== null) type = String(type.type || type[0] || 'file');
                  const iconMap = {pdf: 'pdf.svg', html: 'html.svg', video: 'video.svg'};
                  const iconKey = String(type).startsWith('video') ? 'video' : (iconMap[type] ? type : 'file');
                  const icon = iconMap[iconKey] || 'file.svg';
                  return `<img src="/assets/images/icons/${icon}" title="${type}" style="height:35px;">`;
               },
               hozAlign: 'center'
            },
            {
               title: isChinese ? (window.t ? window.t('contentmgr.title_c') : 'Title C') : (window.t ? window.t('contentmgr.title_e') : 'Title E'),
               field: isChinese ? 'title_c' : 'title_e',
               headerSort: true
            },
            {
               title: isChinese ? (window.t ? window.t('contentmgr.desc_c') : 'Desc C') : (window.t ? window.t('contentmgr.desc_e') : 'Desc E'),
               field: isChinese ? 'desc_c' : 'desc_e',
               headerSort: true
            }
         ],
         paginationDataSent: {page: 'page', size: 'size'},
         ajaxURLGenerator: (url, _config, params) => {
            const qp = new URLSearchParams({page: params.page, size: params.size, keyword: currentKeyword || ''});
            return `${url}?${qp.toString()}`;
         },
         ajaxResponse: (_url, params, response) => {
            const currentPage = response.page ?? params.page;
            const lastPage = response.last_page ?? Math.max(1, Math.ceil((response.total ?? 0) / (params.size || 1)));
            return {
               data: Array.isArray(response.data) ? response.data : [],
               page: currentPage,
               last_page: lastPage,
               total: Number(response.total ?? 0)
            };
         }
      });

      window.contentTable = table;

      table.on('tableBuilt', () => {
         try {
            const footer = contentTableEl.querySelector('.tabulator-footer');
            if (!footer) return;
            const paginationControls = footer.querySelector('.tabulator-paginator');
            const leftDiv = document.createElement('div');
            leftDiv.className = 'tabulator-footer-left';
            const rightDiv = document.createElement('div');
            rightDiv.className = 'tabulator-footer-right';
            if (paginationControls) rightDiv.appendChild(paginationControls);
            if (btnAddWrapper) leftDiv.appendChild(btnAddWrapper);
            footer.innerHTML = '';
            footer.appendChild(leftDiv);
            footer.appendChild(rightDiv);
         } catch (e) { console.warn('tableBuilt footer adjust failed', e); }
      });

      // Delegated actions on table cells
      contentTableEl.addEventListener('click', async (ev) => {
         try {
            const icon = ev.target.closest('[data-action]');
            if (!icon) return;
            const wrapper = icon.closest('.icon-wrapper');
            if (!wrapper) return;
            try {
               ev.preventDefault();
               ev.stopPropagation();
            } catch (e) { /* ignore */ }
            const id = decodeURIComponent(wrapper.dataset.contentId);
            const action = icon.dataset.action;
            const rowObj = window.contentTable.getRow(id)?.getData() || {};
            const isPublished = !!rowObj.is_publish;
            const inUse = !!rowObj.in_use;

            if (action === 'delete') {
               if (isPublished) {
                  showToast(window.t ? window.t('contentmgr.delete_blocked_published') : 'Cannot delete published content', 'info');
                  return;
               }
               const confirmed = await Swal.fire({
                  icon: 'warning',
                  title: window.t ? window.t('contentmgr.confirm_delete_title') : 'Confirm',
                  text: window.t ? window.t('contentmgr.confirm_delete_text') : 'Delete this item?',
                  showCancelButton: true,
                  confirmButtonText: window.t ? window.t('contentmgr.confirm_delete_yes') : 'Yes',
                  cancelButtonText: window.t ? window.t('contentmgr.confirm_delete_cancel') : 'Cancel'
               });
               if (!confirmed.isConfirmed) return;
               const res = await fetch(`/content-mgmt/api/contents/${id}`, {method: 'DELETE'});
               if (!res.ok) throw new Error(await res.text().catch(() => 'Delete failed'));
               window.contentTable?.setData();
               Swal.fire({
                  icon: 'success',
                  title: window.t ? window.t('contentmgr.delete_success') : 'Deleted',
                  timer: 2500,
                  showConfirmButton: false
               });
               return;
            }

            if (action === 'edit') {
               if (isPublished) {
                  showToast(window.t ? window.t('contentmgr.cannot_edit_published') : 'Cannot edit published content', 'info');
                  return;
               }
               openEditModal(id);
               return;
            }

            if (action === 'toggle-publish') {
               const confirmUnpublishRequired = isPublished && inUse;
               const doToggle = async (force = false) => {
                  const actionName = isPublished ? 'unpublish' : 'publish';
                  const url = `/content-mgmt/api/contents/${encodeURIComponent(id)}/${actionName}`;
                  const fetchOptions = force ? {
                     method: 'POST',
                     headers: {'Content-Type': 'application/json'},
                     body: JSON.stringify({force: true})
                  } : {method: 'POST'};
                  const res = await fetch(url, fetchOptions);
                  if (!res.ok) {
                     const txt = await res.text().catch(() => null);
                     throw new Error(txt || `Toggle failed (${res.status})`);
                  }
                  await res.json().catch(() => null);
                  window.contentTable?.setData();
                  Swal.fire({
                     icon: 'success',
                     title: window.t ? window.t('contentmgr.status_updated') : 'Status updated',
                     timer: 1500,
                     showConfirmButton: false
                  });
               };
               if (confirmUnpublishRequired) {
                  const result = await Swal.fire({
                     icon: 'warning',
                     title: window.t ? window.t('contentmgr.confirm_unpublish_title') : 'Confirm',
                     text: window.t ? window.t('contentmgr.confirm_unpublish_text') : 'Unpublish in use content?',
                     showCancelButton: true,
                     confirmButtonText: window.t ? window.t('contentmgr.confirm_unpublish_yes') : 'Yes',
                     cancelButtonText: window.t ? window.t('contentmgr.confirm_unpublish_cancel') : 'Cancel'
                  });
                  if (result.isConfirmed) await doToggle(true);
               } else await doToggle(false);
               return;
            }

            if (action === 'preview') {
               try {
                  const type = rowObj.type || 'pdf';
                  if (type === 'pdf') await openPdfPreviewModal(id);
                  else if (type === 'html') await openHtmlPreviewModal(id);
                  else if (type === 'video') await openVideoPreviewModal(id);
                  else Swal.fire({
                        icon: 'info',
                        title: window.t ? window.t('contentmgr.unsupported_type') : 'Unsupported',
                        text: window.t ? window.t('contentmgr.no_preview_available') : 'No preview available'
                     });
               } catch (err) {
                  console.error('Preview open error:', err);
                  Swal.fire({
                     icon: 'error',
                     title: window.t ? window.t('contentmgr.preview_failed') : 'Preview failed',
                     text: String(err)
                  });
               }
               return;
            }
         } catch (err) {
            console.error('Action handler error:', err);
            Swal.fire({
               icon: 'error',
               title: window.t ? window.t('contentmgr.status_failed') : 'Failed',
               text: err?.toString() || ''
            });
         }
      });

      // Search debounce
      let searchDebounceTimer = null;
      document.getElementById('contentSearch')?.addEventListener('input', (e) => {
         const v = (e.target.value || '').trim();
         currentKeyword = v;
         clearTimeout(searchDebounceTimer);
         searchDebounceTimer = setTimeout(() => window.contentTable?.setPage(1), 300);
      });

      // Add content btn
      el('btnAddContent')?.addEventListener('click', () => {
         window.currentContentId = null;
         openEditModal(null);
      });

      // Initialize Select2 if present
      try {
         $('#categorySelect').select2({
            placeholder: window.t ? window.t('contentmgr.select_categories') : 'Select categories',
            width: '100%'
         });
      } catch (e) { /* ignore */ }

      // Editor / upload toggle
      function toggleEditorAndUpload(type) {
         const isHtml = type === 'html';
         try { quillE?.enable(isHtml); } catch { /* ignore */ }
         try { quillC?.enable(isHtml); } catch { /* ignore */ }

         const wrapper = el('fileUploadWrapper');
         if (wrapper) wrapper.classList.toggle('inactive-upload', isHtml);

         const fileInput = el('contentFileInput');
         if (fileInput) {
            fileInput.disabled = isHtml;
            if (type === 'pdf') fileInput.setAttribute('accept', '.pdf');
            else if (String(type).startsWith('video')) fileInput.setAttribute('accept', 'video/mp4,video/x-msvideo,video/webm,video/quicktime');
            else fileInput.removeAttribute('accept');
         }

         if (uploadTriggerBtn) {
            uploadTriggerBtn.classList.toggle('disabled', isHtml);
            uploadTriggerBtn.style.pointerEvents = isHtml ? 'none' : 'auto';
            uploadTriggerBtn.style.opacity = isHtml ? '0.5' : '1';
         }
      }

      // wire type radios idempotently
      document.querySelectorAll("input[name='contentType']").forEach(radio => {
         const handler = (e) => toggleEditorAndUpload(e.target.value);
         if (radio._toggleHandler) radio.removeEventListener('change', radio._toggleHandler);
         radio.addEventListener('change', handler);
         radio._toggleHandler = handler;
      });

      // Confirm save
      el('confirmSaveContent')?.addEventListener('click', async () => {
         try {
            const type = document.querySelector("input[name='contentType']:checked")?.value || 'html';
            const getVal = (id) => (el(id)?.value ?? '').trim();
            const payload = {
               title_e: getVal('titleEInput'),
               title_c: getVal('titleCInput'),
               desc_e: getVal('descEInput'),
               desc_c: getVal('descCInput'),
               html_e: type === 'html' ? (quillE?.root?.innerHTML || '').trim() : '',
               html_c: type === 'html' ? (quillC?.root?.innerHTML || '').trim() : '',
               allow_dnload: !!el('allowDownloadSwitch')?.checked,
               is_public: !!el('isPublicSwitch')?.checked,
               type,
               categories: $('#categorySelect').val() || [],
               token: tempUploadToken,
               orig_fname: tempUploadFilename
            };
            if (!payload.title_e || !payload.title_c) {
               return Swal.fire({
                  icon: 'warning',
                  title: window.t ? window.t('contentmgr.missing_title') : 'Missing title',
                  text: window.t ? window.t('contentmgr.missing_title_text') : 'Please enter a title.'
               });
            }

            let url = '/content-mgmt/api/contents';
            let method = 'POST';
            if (window.currentContentId) {
               url += `/${encodeURIComponent(window.currentContentId)}`;
               method = 'PUT';
            }

            const res = await fetch(url, {
               method,
               headers: {'Content-Type': 'application/json', Accept: 'application/json'},
               body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error(await res.text());
            $('#contentEditModal').modal('hide');
            window.contentTable?.setData();
            Swal.fire({icon: 'success', title: window.t ? window.t('contentmgr.saved') : 'Saved', timer: 2000});
            tempUploadToken = tempUploadFilename = null;
            window.currentContentId = null;
         } catch (err) {
            console.error('Save error:', err);
            Swal.fire({
               icon: 'error',
               title: window.t ? window.t('contentmgr.save_failed') : 'Save failed',
               text: err.message || ''
            });
         }
      });

      // Cancel edit
      el('cancelEditContent')?.addEventListener('click', () => {
         try { el('contentEditForm')?.reset(); } catch { /* ignore */ }
         try { $('#categorySelect').val(null).trigger('change'); } catch { /* ignore */ }
         try { bootstrap.Modal.getInstance(el('contentEditModal'))?.hide(); } catch { /* ignore */ }
         tempUploadToken = tempUploadFilename = null;
         window.currentContentId = null;
      });

      $('#contentEditModal').on('hidden.bs.modal', () => {
         window.currentContentId = null;
      });

      // openEditModal consolidated
      async function openEditModal(contentId) {
         const explicitId = contentId || null;
         const url = explicitId ? `/content-mgmt/api/contents/${encodeURIComponent(explicitId)}` : null;
         const modalEl = el('contentEditModal');
         if (!modalEl) {
            console.warn('openEditModal: missing #contentEditModal');
            return;
         }

         // ensure editors initialized
         if (!quillE) try { quillE = new Quill('#htmlEditorE', {theme: 'snow'}); } catch (e) {
            quillE = null;
            console.warn('QuillE init failed', e);
         }
         if (!quillC) try { quillC = new Quill('#htmlEditorC', {theme: 'snow'}); } catch (e) {
            quillC = null;
            console.warn('QuillC init failed', e);
         }

         const populateFrom = (data = {}) => {
            try {
               if (!window.currentContentId && data.content_id) window.currentContentId = data.content_id;
               const labelEl = el('contentModalLabel');
               if (labelEl) labelEl.textContent = (data.content_id ? (window.t ? window.t('contentmgr.edit') : 'Edit') : (window.t ? window.t('contentmgr.add') : 'Add'));
               $('#contentEditModal').modal('show');

               const fieldMap = {
                  titleEInput: 'title_e',
                  descEInput: 'desc_e',
                  titleCInput: 'title_c',
                  descCInput: 'desc_c'
               };
               Object.entries(fieldMap).forEach(([inputId, jsonKey]) => {
                  const targ = el(inputId);
                  if (targ) targ.value = data[jsonKey] ?? '';
               });

               try {
                  if (quillE && typeof quillE.clipboard === 'object') {
                     quillE.setContents([]);
                     quillE.clipboard.dangerouslyPasteHTML(data.html_e || '');
                  } else (document.querySelector('#htmlEditorE .ql-editor') || document.querySelector('#htmlEditorE')).innerHTML = data.html_e || '';
               } catch (e) { console.warn('populate quillE failed', e); }

               try {
                  if (quillC && typeof quillC.clipboard === 'object') {
                     quillC.setContents([]);
                     quillC.clipboard.dangerouslyPasteHTML(data.html_c || '');
                  } else (document.querySelector('#htmlEditorC .ql-editor') || document.querySelector('#htmlEditorC')).innerHTML = data.html_c || '';
               } catch (e) { console.warn('populate quillC failed', e); }

               const allowEl = el('allowDownloadSwitch');
               if (allowEl) allowEl.checked = !!data.allow_dnload;
               const publicEl = el('isPublicSwitch');
               if (publicEl) publicEl.checked = !!data.is_public;

               const type = data.type || document.querySelector("input[name='contentType']:checked")?.value || 'html';
               const radio = document.querySelector(`input[name='contentType'][value='${type}']`);
               if (radio) radio.checked = true;
               toggleEditorAndUpload(type);

               if (selectedFileNameEl) {
                  selectedFileNameEl.textContent = (type !== 'html') ? (data.orig_fname || (data.file_location || '').split(/[\\/]/).pop() || (window.t ? window.t('contentmgr.no_chosen') : 'No file chosen')) : (window.t ? window.t('contentmgr.no_chosen') : 'No file chosen');
               }

               const cats = Array.isArray(data.categories) ? data.categories : [];
               try { $('#categorySelect').val(cats).trigger('change'); } catch (e) {
                  const sel = el('categorySelect');
                  if (sel && sel.options) for (let i = 0; i < sel.options.length; i++) sel.options[i].selected = cats.includes(sel.options[i].value);
               }
            } catch (e) { console.warn('populateFrom error', e); }
         };

         if (!url) {
            populateFrom({});
            return;
         }

         try {
            const res = await fetch(url, {credentials: 'include'});
            if (!res.ok) {
               populateFrom({});
               return;
            }
            const json = await res.json().catch(() => null);
            const data = json && json.data ? json.data : {};
            populateFrom(data);
         } catch (err) {
            console.warn('openEditModal network error', err);
            populateFrom({});
         }
      }

      // Upload wiring (modal+global safe single-binding)
      (function safeSingleUploadWiring() {
         const globalFileInput = el('fileUploadInput');
         const modalFileInput = el('contentFileInput');

         const bindOnce = (elRef, ev, handler, flag) => {
            if (!elRef) return;
            if (elRef[flag]) return;
            elRef.addEventListener(ev, handler);
            elRef[flag] = true;
         };

         const openFilePicker = (e) => {
            if (e) {
               try {
                  e.preventDefault();
                  e.stopPropagation();
               } catch (e) { }
            }
            const modalShown = !!document.querySelector('#contentEditModal.show');
            const target = (modalShown && modalFileInput && !modalFileInput.disabled) ? modalFileInput : (globalFileInput && !globalFileInput.disabled ? globalFileInput : null);
            if (!target) return;
            setTimeout(() => {
               try { target.click(); } catch (err) { console.warn('file input click failed', err); }
            }, 0);
         };

         bindOnce(uploadTriggerBtn, 'click', openFilePicker, '_safeUploadBound');

         bindOnce(modalFileInput, 'change', async function () {
            const file = this.files && this.files[0];
            if (!file) {
               if (selectedFileNameEl) selectedFileNameEl.textContent = window.t ? window.t('contentmgr.no_chosen') : 'No file chosen';
               tempUploadToken = tempUploadFilename = null;
               return;
            }

            if (selectedFileNameEl) selectedFileNameEl.textContent = file.name;
            tempUploadToken = generateTempToken();

            const progressWrapper = el('uploadProgressWrapper');
            const progressBar = el('uploadProgressBar');
            const progressText = el('uploadProgressText');
            const cancelBtn = el('uploadCancelBtn');

            if (progressWrapper) progressWrapper.style.display = 'block';
            if (progressBar) progressBar.style.width = '0%';
            if (progressText) progressText.textContent = window.t ? (window.t('contentmgr.uploading') || 'Uploading') : 'Uploading';

            const onCancel = () => {
               cancelCurrentUpload();
               if (progressWrapper) progressWrapper.style.display = 'none';
               tempUploadToken = tempUploadFilename = null;
               if (selectedFileNameEl) selectedFileNameEl.textContent = window.t ? window.t('contentmgr.no_chosen') : 'No file chosen';
               showToast(window.t ? window.t('contentmgr.upload_cancelled') : 'Upload cancelled', 'info');
            };
            if (cancelBtn) {
               cancelBtn.removeEventListener('click', onCancel);
               cancelBtn.addEventListener('click', onCancel);
            }

            try {
               const result = await uploadFileWithProgress(file, tempUploadToken, (percent, loaded) => {
                  if (percent !== null && progressBar) progressBar.style.width = `${percent}%`;
                  if (progressText) {
                     if (percent !== null) progressText.textContent = `${percent}% (${(loaded / 1024 / 1024).toFixed(2)}MB)`;
                     else progressText.textContent = `${(loaded / 1024 / 1024).toFixed(2)}MB uploaded`;
                  }
               });

               tempUploadFilename = result?.data?.orig_fname || file.name;
               if (progressText) progressText.textContent = window.t ? (window.t('contentmgr.upload_success') || 'Uploaded') : 'Uploaded';
               showToast(window.t ? window.t('contentmgr.upload_success') : 'File uploaded', 'success');
               try {
                  Swal.fire({
                     icon: 'success',
                     title: window.t ? (window.t('contentmgr.upload_success') || 'Uploaded') : 'Uploaded',
                     text: tempUploadFilename,
                     showConfirmButton: false,
                     timer: 1400,
                     toast: false,
                     position: 'center'
                  });
               } catch { /* ignore */ }
            } catch (err) {
               console.error('Temp upload error:', err);
               showToast(window.t ? window.t('contentmgr.upload_failed') : 'Upload failed', 'error');
               tempUploadToken = tempUploadFilename = null;
               if (selectedFileNameEl) selectedFileNameEl.textContent = window.t ? window.t('contentmgr.no_chosen') : 'No file chosen';
            } finally {
               if (progressWrapper) setTimeout(() => {
                  progressWrapper.style.display = 'none';
               }, 800);
               try { this.value = ''; } catch { /* ignore */ }
               if (cancelBtn) cancelBtn.removeEventListener('click', onCancel);
            }
         }, '_safeModalChangeBound');
      })();

      // PDF helpers
      async function renderPageToCanvasHighDPI(page, targetCssWidthPx, dpr = window.devicePixelRatio || 1, zoomFactor = 1) {
         if (!window.__pdfMeasureResolved) await window.__pdfMeasurePromise;
         if (!targetCssWidthPx || targetCssWidthPx < 120) {
            const viewerEl = el('pdfViewerCanvas');
            targetCssWidthPx = window.__pdfMeasuredWidth || (viewerEl ? Math.max(100, Math.floor(viewerEl.clientWidth || viewerEl.getBoundingClientRect().width)) : 600);
            window.__pdfMeasuredWidth = Math.max(100, Math.floor(targetCssWidthPx));
         }
         const unscaledVp = page.getViewport({scale: 1});
         const logicalScale = (targetCssWidthPx / unscaledVp.width) * (zoomFactor || 1);
         const vp = page.getViewport({scale: logicalScale});

         const canvas = document.createElement('canvas');
         const ctx = canvas.getContext('2d', {alpha: false});
         canvas.dataset.pdfPage = String(page.pageNumber || (page._pageIndex + 1));

         canvas.width = Math.round(vp.width * dpr);
         canvas.height = Math.round(vp.height * dpr);

         const cssWidth = Math.round(targetCssWidthPx);
         const cssHeight = Math.round((vp.height / vp.width) * cssWidth);
         canvas.style.width = `${cssWidth}px`;
         canvas.style.height = `${cssHeight}px`;
         canvas.className = 'pdf-page-canvas';

         if (ctx.setTransform) ctx.setTransform(dpr, 0, 0, dpr, 0, 0); else ctx.scale(dpr, dpr);

         await page.render({canvasContext: ctx, viewport: vp}).promise;
         return canvas;
      }

      async function fetchWithRetries(url, opts = {}, retries = 3, delayMs = 300) {
         for (let i = 0; i <= retries; i++) {
            try {
               const r = await fetch(url, opts).catch(() => null);
               if (r && r.ok) return r;
               if (i === retries) return r;
            } catch (e) { if (i === retries) return null; }
            await new Promise(res => setTimeout(res, delayMs * (i + 1)));
         }
         return null;
      }

      // PDF Preview Modal (concurrency-limited rendering)
      async function openPdfPreviewModal(contentId) {
         const previewModalEl = el('contentPreviewModal');
         const previewContainer = el('previewContainer');
         if (!previewModalEl || !previewContainer) return;

         let cancelled = false;
         const cancel = () => {
            cancelled = true;
         };

         const setProgress = (text) => {
            try {
               const elp = previewContainer.querySelector('.pdf-progress');
               if (elp) elp.textContent = text;
            } catch (e) { }
         };
         const showError = (msg) => {
            try {
               if (window.Swal && Swal.fire) Swal.fire({
                  icon: 'error',
                  title: 'Preview failed',
                  text: msg
               }); else alert(msg);
            } catch (e) { console.error(msg); }
         };

         previewContainer.innerHTML = `
        <div class="pdf-preview-wrapper" style="display:flex;flex-direction:column;gap:8px;">
          <div id="pdfViewerToolbar" class="pdf-toolbar" style="display:flex;gap:8px;align-items:center;">
            <button id="pdfPrev" class="rbt-btn" type="button">Prev</button>
            <button id="pdfNext" class="rbt-btn" type="button">Next</button>
            <span id="pdfPageInfo" style="margin-left:8px"></span>
            <div style="margin-left:auto"><span class="pdf-progress" style="color:#666"></span></div>
          </div>
          <div id="pdfViewerCanvas" class="pdf-viewer-canvas" style="overflow:auto;flex:1;padding:8px;background:#fff;border:1px solid #eee;min-height:300px;"></div>
        </div>`;

         // resolve global width gate
         try {
            const viewerEl = el('pdfViewerCanvas');
            if (typeof resolvePdfMeasureSafely === 'function') {
               try { resolvePdfMeasureSafely(viewerEl.clientWidth || viewerEl.getBoundingClientRect().width || 600); } catch (e) { }
            } else {
               try { if (window.__resolvePdfMeasure && !window.__pdfMeasureResolved) window.__resolvePdfMeasure(viewerEl.clientWidth || 600); } catch (e) { }
            }
         } catch (e) { /* ignore */ }

         const viewer = el('pdfViewerCanvas');
         const pageInfo = el('pdfPageInfo');
         const prevBtn = el('pdfPrev');
         const nextBtn = el('pdfNext');

         let currentPage = 1, totalPages = 0;
         const updatePageInfo = () => {
            if (pageInfo) pageInfo.textContent = `Page ${currentPage} / ${totalPages || '?'}`;
         };
         const scrollToPage = (idx) => {
            if (!viewer) return;
            const target = viewer.querySelector(`[data-pdf-page="${idx}"]`);
            if (target) target.scrollIntoView({behavior: 'smooth', block: 'start'});
            currentPage = idx;
            updatePageInfo();
         };
         if (prevBtn && !prevBtn._bound) {
            prevBtn.addEventListener('click', () => {
               if (currentPage > 1) scrollToPage(currentPage - 1);
            });
            prevBtn._bound = true;
         }
         if (nextBtn && !nextBtn._bound) {
            nextBtn.addEventListener('click', () => {
               if (currentPage < totalPages) scrollToPage(currentPage + 1);
            });
            nextBtn._bound = true;
         }

         setProgress('Loading PDF');
         let arrayBuffer = null;
         try {
            arrayBuffer = await (async () => {
               const r = await fetchWithRetries(`/content-mgmt/api/contents/${encodeURIComponent(contentId)}/stream`, {credentials: 'include'}, 3, 300);
               if (!r) throw new Error('No response');
               if (!r.ok) throw new Error(await r.text().catch(() => `Status ${r.status}`));
               return await r.arrayBuffer();
            })();
         } catch (err) {
            showError(String(err));
            return;
         }
         if (cancelled) return;

         let pdfDoc;
         try { pdfDoc = await window.pdfjsLib.getDocument({data: arrayBuffer}).promise; } catch (err) {
            showError('Unable to parse PDF');
            return;
         }

         totalPages = pdfDoc.numPages || 0;
         updatePageInfo();
         setProgress(`Rendering 0 / ${totalPages}`);

         const renderPageToCanvas = async (pageNum) => {
            if (cancelled) return null;
            try {
               const page = await pdfDoc.getPage(pageNum);
               if (typeof renderPageToCanvasHighDPI === 'function') {
                  const canvas = await renderPageToCanvasHighDPI(page, window.__pdfMeasuredWidth || Math.min(900, Math.floor(window.innerWidth * 0.9)));
                  canvas.dataset.pdfPage = pageNum;
                  return canvas;
               } else {
                  const viewport = page.getViewport({scale: 1.5});
                  const canvas = document.createElement('canvas');
                  canvas.width = viewport.width;
                  canvas.height = viewport.height;
                  canvas.dataset.pdfPage = pageNum;
                  const ctx = canvas.getContext('2d');
                  await page.render({canvasContext: ctx, viewport}).promise;
                  return canvas;
               }
            } catch (e) {
               console.warn('render page failed', pageNum, e);
               return null;
            }
         };

         const concurrency = Math.max(1, Math.min(4, Math.floor((navigator.hardwareConcurrency || 2))));
         const toRender = Array.from({length: totalPages}, (_, i) => i + 1);
         let rendered = 0;

         const runQueue = async () => {
            while (toRender.length && !cancelled) {
               const pageNum = toRender.shift();
               const canvas = await renderPageToCanvas(pageNum);
               if (canvas && viewer && !cancelled) viewer.appendChild(canvas);
               rendered++;
               setProgress(`Rendering ${rendered} / ${totalPages}`);
               await new Promise(r => setTimeout(r, 8));
            }
         };

         const runners = [];
         for (let i = 0; i < concurrency; i++) runners.push(runQueue());

         const scrollCheck = () => {
            if (!viewer) return;
            const rect = viewer.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2;
            const pages = Array.from(viewer.querySelectorAll('canvas'));
            let best = null, bestDist = Infinity;
            for (const c of pages) {
               const r = c.getBoundingClientRect();
               const mid = r.top + r.height / 2;
               const dist = Math.abs(mid - centerY);
               if (dist < bestDist) {
                  bestDist = dist;
                  best = c;
               }
            }
            if (best) {
               const idx = Number(best.dataset.pdfPage) || 1;
               if (idx !== currentPage) {
                  currentPage = idx;
                  updatePageInfo();
               }
            }
         };

         let scrollTimer = null;
         viewer.addEventListener('scroll', () => {
            clearTimeout(scrollTimer);
            scrollTimer = setTimeout(scrollCheck, 120);
         });

         const modal = new bootstrap.Modal(previewModalEl, {backdrop: 'static'});
         modal.show();

         const onHidden = () => {
            cancel();
            try {
               viewer.removeEventListener('scroll', () => {
               });
            } catch (e) { }
            try { viewer.querySelectorAll('canvas').forEach(c => c.remove()); } catch (e) {}
            setProgress('');
         };
         previewModalEl.addEventListener('hidden.bs.modal', onHidden, {once: true});

         try {
            await Promise.all(runners);
            if (!cancelled) setProgress('Rendered');
         } catch (e) { console.warn('rendering interrupted', e); }
         if (!cancelled) scrollCheck();
      }

      // Video preview modal (stream + watermark + reading stats)
      const openVideoPreviewModal = async (contentId) => {
         return new Promise(async (resolve, reject) => {
            let modalClosed = false, previewEndSent = false;
            try {
               const previewModalEl = el('contentPreviewModal');
               const previewContainer = el('previewContainer');
               if (!previewModalEl || !previewContainer) throw new Error('Preview modal or container not found');

               const startRes = await fetch(`/content-mgmt/api/contents/${encodeURIComponent(contentId)}/preview-video`, {
                  method: 'POST',
                  credentials: 'include',
                  headers: {'Content-Type': 'application/json'},
                  body: JSON.stringify({})
               });
               if (!startRes || !startRes.ok) {
                  const txt = await startRes?.text().catch(() => null);
                  throw new Error(txt || `Preview start failed (${startRes?.status || 'no response'})`);
               }
               const startJson = await startRes.json().catch(() => ({}));
               const {streamUrl, watermarkMessage, session_key} = startJson;
               const sessionKey = session_key || null;
               const streamSrc = streamUrl;

               let resumePos = 0;
               try {
                  const rr = await fetch(`/content-mgmt/api/contents/${encodeURIComponent(contentId)}/resume`, {
                     method: 'GET',
                     credentials: 'include'
                  });
                  if (rr && rr.ok) {
                     const jr = await rr.json().catch(() => null);
                     if (jr && jr.success && Number.isFinite(Number(jr.position))) resumePos = Math.max(0, Number(jr.position));
                  }
               } catch (e) { console.warn('resume fetch failed', e); }

               previewContainer.innerHTML = `
<div class="video-preview-wrapper" style="position:relative;height:80vh;display:flex;flex-direction:column;">
  <div id="videoToolbar" style="display:flex;gap:8px;padding:8px;align-items:center;z-index:50;">
    <button id="videoPlay" class="rbt-btn">Play</button>
    <button id="videoPause" class="rbt-btn">Pause</button>
    <div id="videoTimeInfo" style="margin-left:8px;"></div>
  </div>
  <div id="videoViewer" style="flex:1;display:flex;align-items:center;justify-content:center;background:#111;position:relative;">
    <video id="previewVideo" playsinline webkit-playsinline controlslist="nodownload" style="max-width:100%;max-height:100%;outline:none;background:#000;"></video>
    <div id="videoWatermark" style="pointer-events:none;position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:60;opacity:0.10;font-size:20px;font-weight:700;color:#fff;transform:rotate(-20deg);mix-blend-mode:overlay;"></div>
  </div>
</div>`;

               const video = previewContainer.querySelector('#previewVideo');
               const playBtn = previewContainer.querySelector('#videoPlay');
               const pauseBtn = previewContainer.querySelector('#videoPause');
               const timeInfo = previewContainer.querySelector('#videoTimeInfo');
               const watermarkEl = previewContainer.querySelector('#videoWatermark');
               const videoViewer = previewContainer.querySelector('#videoViewer');

               if (!video) throw new Error('Video element not found');

               if (watermarkEl) {
                  watermarkEl.textContent = watermarkMessage || '';
                  watermarkEl.style.display = watermarkMessage ? 'flex' : 'none';
               }
               try { video.setAttribute('controlslist', 'nodownload'); } catch { }
               try { video.setAttribute('disablePictureInPicture', ''); } catch { }
               video.style.userSelect = 'none';
               const prevent = (e) => {
                  try {
                     e.preventDefault();
                     e.stopPropagation();
                  } catch { }
                  return false;
               };
               try {
                  video.addEventListener('contextmenu', prevent);
                  video.addEventListener('dragstart', prevent);
               } catch { }

               if (streamSrc) video.src = streamSrc;

               // reading stats helpers
               let lastKnownPosition = 0;
               const sendReadingEvent = (payload = {}, preferBeacon = false) => {
                  if (modalClosed && payload?.action !== 'preview_end') return;
                  if (payload?.action === 'preview_end') {
                     if (previewEndSent) return;
                     previewEndSent = true;
                  }
                  const body = Object.assign({
                     user_id: window?.userId || null,
                     content_id: contentId,
                     session_key: sessionKey,
                     is_preview: true,
                     ts: Date.now(),
                     position: Math.floor(lastKnownPosition || 0)
                  }, payload);
                  try {
                     if (navigator && typeof navigator.sendBeacon === 'function' && (preferBeacon || payload?.action === 'preview_end' || payload?.action === 'pause')) {
                        const blob = new Blob([JSON.stringify(body)], {type: 'application/json'});
                        navigator.sendBeacon('/content-mgmt/api/reading-stats', blob);
                        return;
                     }
                  } catch (e) { /* ignore */ }
                  if (modalClosed) return;
                  fetch('/content-mgmt/api/reading-stats', {
                     method: 'POST',
                     credentials: 'include',
                     headers: {'Content-Type': 'application/json'},
                     body: JSON.stringify(body)
                  }).catch(() => {
                  });
               };

               const applyResume = () => {
                  try {
                     const dur = isFinite(video.duration) ? video.duration : 0;
                     if (dur > 0 && resumePos > 0 && resumePos < Math.max(1, Math.floor(dur) - 1)) {
                        video.currentTime = Math.min(resumePos, dur - 0.5);
                        sendReadingEvent({
                           action: 'resume',
                           position: Math.floor(video.currentTime || resumePos)
                        });
                     }
                  } catch (e) { /* ignore */ }
               };
               if (video.readyState >= 1) applyResume(); else video.addEventListener('loadedmetadata', applyResume, {once: true});

               const updateTimeInfo = () => {
                  try {
                     const dur = Number.isFinite(video.duration) ? video.duration : 0;
                     const pos = Number.isFinite(video.currentTime) ? video.currentTime : 0;
                     if (timeInfo) timeInfo.textContent = ` ${Math.floor(pos)}s / ${dur ? Math.floor(dur) : 0}s`;
                  } catch (e) { /* ignore */ }
               };

               let progressWrap = el('videoProgressWrap');
               if (!progressWrap) {
                  progressWrap = document.createElement('div');
                  progressWrap.id = 'videoProgressWrap';
                  progressWrap.style.cssText = 'position:absolute;left:8px;right:8px;bottom:12px;height:10px;background:rgba(255,255,255,0.06);border-radius:6px;cursor:pointer;touch-action:none;z-index:40;';
                  const pb = document.createElement('div');
                  pb.id = 'videoProgressBar';
                  pb.style.cssText = 'width:0%;height:100%;background:linear-gradient(90deg,#1e90ff,#00d4ff);border-radius:6px;';
                  progressWrap.appendChild(pb);
                  try { (videoViewer || video.parentElement).appendChild(progressWrap); } catch { (video.parentElement || document.body).appendChild(progressWrap); }
               }
               const progressBar = document.getElementById('videoProgressBar');

               const clientXFromEvent = (ev) => {
                  if (!ev) return 0;
                  if (ev.touches && ev.touches[0]) return ev.touches[0].clientX;
                  if (ev.changedTouches && ev.changedTouches[0]) return ev.changedTouches[0].clientX;
                  return ev.clientX ?? ev.pageX ?? 0;
               };
               const computeTimeFromClientX = (clientX) => {
                  const rect = progressWrap.getBoundingClientRect();
                  let x = clientX - rect.left;
                  x = Math.max(0, Math.min(rect.width, x));
                  const pct = rect.width > 0 ? x / rect.width : 0;
                  const dur = isFinite(video.duration) ? video.duration : 0;
                  return dur > 0 ? pct * dur : 0;
               };
               const setProgressBarFromVideo = () => {
                  try {
                     const dur = isFinite(video.duration) ? video.duration : 0;
                     const pos = isFinite(video.currentTime) ? video.currentTime : 0;
                     const pct = dur > 0 ? Math.max(0, Math.min(1, pos / dur)) * 100 : 0;
                     if (progressBar) progressBar.style.width = `${pct}%`;
                  } catch { /* ignore */ }
               };

               const updateLastKnownPosition = (pos) => {
                  try {
                     if (!Number.isFinite(pos)) return;
                     const p = Math.max(0, Math.floor(pos));
                     if (p > lastKnownPosition) lastKnownPosition = p;
                  } catch (e) { }
               };

               // Seek/drag handlers
               let dragging = false, dragWasPlaying = false, dragStartFrom = 0;
               const onPointerDown = (ev) => {
                  try {
                     ev?.preventDefault?.();
                     dragging = true;
                     dragWasPlaying = !video.paused && !video.ended;
                     dragStartFrom = Math.floor(video.currentTime || 0);
                     sendReadingEvent({action: 'seek_start', from: dragStartFrom});
                     const t = computeTimeFromClientX(clientXFromEvent(ev));
                     try { video.currentTime = t; } catch { }
                     setProgressBarFromVideo();
                     updateTimeInfo();
                     if (dragWasPlaying) video.pause();
                  } catch (e) { }
               };
               const onPointerMove = (ev) => {
                  if (!dragging) return;
                  try {
                     ev?.preventDefault?.();
                     const t = computeTimeFromClientX(clientXFromEvent(ev));
                     try { video.currentTime = t; } catch { }
                     setProgressBarFromVideo();
                     updateTimeInfo();
                  } catch (e) { }
               };
               const onPointerUp = (ev) => {
                  if (!dragging) return;
                  try {
                     ev?.preventDefault?.();
                     dragging = false;
                     const t = computeTimeFromClientX(clientXFromEvent(ev));
                     try { video.currentTime = t; } catch { }
                     setProgressBarFromVideo();
                     updateTimeInfo();
                     sendReadingEvent({
                        action: 'seek_end',
                        from: dragStartFrom,
                        to: Math.floor(t),
                        position: Math.floor(t)
                     });
                     updateLastKnownPosition(t);
                     if (dragWasPlaying) video.play().catch(() => {
                     });
                  } catch (e) { }
               };
               const onClickProgress = (ev) => {
                  try {
                     const t = computeTimeFromClientX(clientXFromEvent(ev));
                     const from = Math.floor(video.currentTime || 0);
                     try { video.currentTime = t; } catch { }
                     setProgressBarFromVideo();
                     updateTimeInfo();
                     sendReadingEvent({action: 'seek_start', from});
                     sendReadingEvent({action: 'seek_end', from, to: Math.floor(t), position: Math.floor(t)});
                     updateLastKnownPosition(t);
                  } catch (e) { }
               };

               const supportsPointer = !!window.PointerEvent;
               try {
                  if (supportsPointer) {
                     progressWrap.removeEventListener('pointerdown', onPointerDown);
                     progressWrap.addEventListener('pointerdown', onPointerDown);
                     window.removeEventListener('pointermove', onPointerMove);
                     window.addEventListener('pointermove', onPointerMove);
                     window.removeEventListener('pointerup', onPointerUp);
                     window.addEventListener('pointerup', onPointerUp);
                     window.removeEventListener('pointercancel', onPointerUp);
                     window.addEventListener('pointercancel', onPointerUp);
                  } else {
                     progressWrap.removeEventListener('mousedown', onPointerDown);
                     progressWrap.addEventListener('mousedown', onPointerDown);
                     window.removeEventListener('mousemove', onPointerMove);
                     window.addEventListener('mousemove', onPointerMove);
                     window.removeEventListener('mouseup', onPointerUp);
                     window.addEventListener('mouseup', onPointerUp);
                     progressWrap.removeEventListener('touchstart', onPointerDown);
                     progressWrap.addEventListener('touchstart', onPointerDown, {passive: false});
                     window.removeEventListener('touchmove', onPointerMove);
                     window.addEventListener('touchmove', onPointerMove, {passive: false});
                     window.removeEventListener('touchend', onPointerUp);
                     window.addEventListener('touchend', onPointerUp);
                     window.removeEventListener('touchcancel', onPointerUp);
                     window.addEventListener('touchcancel', onPointerUp);
                  }
                  progressWrap.removeEventListener('click', onClickProgress);
                  progressWrap.addEventListener('click', onClickProgress);
               } catch { /* ignore */ }

               const onTimeUpdateHandler = () => {
                  try {
                     setProgressBarFromVideo();
                     updateTimeInfo();
                     updateLastKnownPosition(video.currentTime || 0);
                  } catch (e) { }
               };
               try { video.removeEventListener('timeupdate', onTimeUpdateHandler); } catch { }
               video.addEventListener('timeupdate', onTimeUpdateHandler);

               // heartbeat/watch aggregation
               let playStartTs = 0, accumulatedSec = 0, heartbeatTimer = null;
               const HEARTBEAT_SEC = 10, MIN_SEND_DELTA = 5;
               let lastPersistedSeconds = 0;
               const heartbeatTick = () => {
                  try {
                     let nowSecs = accumulatedSec;
                     if (playStartTs) nowSecs += (Date.now() - playStartTs) / 1000;
                     const seconds = Math.floor(Math.max(0, nowSecs));
                     if (seconds - lastPersistedSeconds >= MIN_SEND_DELTA) {
                        lastPersistedSeconds = seconds;
                        sendReadingEvent({action: 'watch', position: Math.floor(video.currentTime || 0)});
                     }
                  } catch (e) { }
               };
               const startHeartbeat = () => {
                  if (!heartbeatTimer) heartbeatTimer = setInterval(heartbeatTick, HEARTBEAT_SEC * 1000);
               };
               const stopHeartbeat = () => {
                  if (heartbeatTimer) clearInterval(heartbeatTimer);
                  heartbeatTimer = null;
               };

               const onPlayHandler = () => {
                  try {
                     playStartTs = Date.now();
                     startHeartbeat();
                     sendReadingEvent({action: 'play', position: Math.floor(video.currentTime || 0)});
                  } catch (e) { }
               };
               const onPauseHandler = () => {
                  try {
                     if (playStartTs) accumulatedSec += (Date.now() - playStartTs) / 1000;
                     playStartTs = 0;
                     stopHeartbeat();
                     sendReadingEvent({action: 'pause', position: Math.floor(video.currentTime || 0)}, true);
                  } catch (e) { }
               };

               try {
                  video.removeEventListener('play', onPlayHandler);
                  video.removeEventListener('pause', onPauseHandler);
               } catch { }
               video.addEventListener('play', onPlayHandler);
               video.addEventListener('pause', onPauseHandler);

               if (playBtn) {
                  try {
                     playBtn.removeEventListener('click', playBtn.__playHandler || (() => {
                     }));
                  } catch { }
                  playBtn.__playHandler = () => video.play().catch(() => {
                  });
                  playBtn.addEventListener('click', playBtn.__playHandler);
               }
               if (pauseBtn) {
                  try {
                     pauseBtn.removeEventListener('click', pauseBtn.__pauseHandler || (() => {
                     }));
                  } catch { }
                  pauseBtn.__pauseHandler = () => video.pause();
                  pauseBtn.addEventListener('click', pauseBtn.__pauseHandler);
               }

               // watermark: create few randomized overlays (non-blocking)
               const createFourTextWatermarks = (sessionKeyVal, watermarkMsgVal, opts = {}) => {
                  const wmContainerId = `video-txt-wm-${contentId}-${sessionKeyVal || 'anon'}`;
                  let wmContainer = document.getElementById(wmContainerId);
                  if (wmContainer) wmContainer.remove();
                  wmContainer = document.createElement('div');
                  wmContainer.id = wmContainerId;
                  wmContainer.style.position = 'absolute';
                  wmContainer.style.inset = '0';
                  wmContainer.style.pointerEvents = 'none';
                  wmContainer.style.zIndex = '62';
                  wmContainer.style.display = 'block';

                  const baseFontVh = typeof opts.baseFontVh === 'number' ? opts.baseFontVh : 8;
                  const heightVh = typeof opts.heightVh === 'number' ? opts.heightVh : 30;
                  const opacity = typeof opts.opacity === 'number' ? opts.opacity : 0.18;
                  const colorRgb = opts.colorRgb || '255,255,255';
                  const maxFontPx = typeof opts.maxFontPx === 'number' ? opts.maxFontPx : 50;
                  const minFontPx = typeof opts.minFontPx === 'number' ? opts.minFontPx : 18;
                  const randomize = opts.randomize !== false;

                  let rnd = Math.random;
                  if (opts.seed && typeof opts.seed === 'string') {
                     let t = Array.from(opts.seed).reduce((s, ch) => s + ch.charCodeAt(0), 0) >>> 0;
                     rnd = () => {
                        t += 0x6D2B79F5;
                        let r = Math.imul(t ^ (t >>> 15), 1 | t);
                        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
                        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
                     };
                  }

                  const candidateAnchors = [
                     {x: 20, y: 25, baseRotate: -20}, {x: 80, y: 25, baseRotate: -15}, {
                        x: 20,
                        y: 50,
                        baseRotate: -25
                     },
                     {x: 80, y: 50, baseRotate: -18}, {x: 35, y: 82, baseRotate: -24}, {
                        x: 65,
                        y: 82,
                        baseRotate: -20
                     },
                     {x: 50, y: 30, baseRotate: -22}
                  ];
                  const shuffled = (arr) => {
                     const copy = arr.slice();
                     for (let i = copy.length - 1; i > 0; i--) {
                        const j = Math.floor(rnd() * (i + 1));
                        const tmp = copy[i];
                        copy[i] = copy[j];
                        copy[j] = tmp;
                     }
                     return copy;
                  };
                  const chosenAnchors = randomize ? shuffled(candidateAnchors).slice(0, 3) : candidateAnchors.slice(0, 3);

                  chosenAnchors.forEach((anchor) => {
                     const jitter = randomize ? (rnd() * 8 - 4) : 0;
                     const xPct = Math.max(5, Math.min(95, anchor.x + jitter));
                     const yPct = Math.max(8, Math.min(92, anchor.y + (randomize ? (rnd() * 8 - 4) : 0)));
                     const rotate = anchor.baseRotate + (randomize ? Math.round((rnd() * 12) - 6) : 0);

                     const wrap = document.createElement('div');
                     wrap.style.position = 'absolute';
                     wrap.style.left = `${xPct}%`;
                     wrap.style.top = `${yPct}%`;
                     wrap.style.transform = 'translate(-50%,-50%)';
                     wrap.style.pointerEvents = 'none';
                     wrap.style.display = 'flex';
                     wrap.style.alignItems = 'center';
                     wrap.style.justifyContent = 'center';

                     const txt = document.createElement('div');
                     txt.textContent = watermarkMsgVal || (sessionKeyVal || '');
                     txt.style.height = `${heightVh}vh`;
                     txt.style.lineHeight = '1';
                     txt.style.whiteSpace = 'nowrap';
                     txt.style.fontWeight = '700';
                     txt.style.color = `rgba(${colorRgb}, ${opacity})`;
                     txt.style.mixBlendMode = 'overlay';
                     txt.style.fontFamily = 'Helvetica, Arial, sans-serif';
                     txt.style.pointerEvents = 'none';
                     txt.style.userSelect = 'none';
                     txt.style.textAlign = 'center';
                     txt.style.textShadow = '0 0 6px rgba(0,0,0,0.25)';

                     wrap.style.transform = `translate(-50%,-50%) rotate(${rotate}deg)`;
                     wrap.appendChild(txt);
                     wmContainer.appendChild(wrap);

                     requestAnimationFrame(() => {
                        try {
                           const vh = Math.max(200, window.innerHeight || document.documentElement.clientHeight);
                           const basePx = Math.round((baseFontVh / 100) * vh);
                           const scaleFactor = randomize ? (0.85 + (rnd() * 0.3)) : 1;
                           const computedPx = Math.min(maxFontPx, Math.max(minFontPx, Math.round(basePx * scaleFactor)));
                           txt.style.fontSize = `${computedPx}px`;
                           const vw = Math.max(320, window.innerWidth || document.documentElement.clientWidth);
                           const safeMaxW = Math.floor(vw * 0.9);
                           const rect = txt.getBoundingClientRect();
                           if (rect.width > 0 && rect.width > safeMaxW) {
                              const scale = safeMaxW / rect.width;
                              txt.style.transform = `scale(${scale})`;
                           }
                        } catch (e) { /* ignore */ }
                     });
                  });

                  const viewerEl = document.getElementById('videoViewer') || previewContainer;
                  if (viewerEl) {
                     if (getComputedStyle(viewerEl).position === 'static') viewerEl.style.position = 'relative';
                     viewerEl.appendChild(wmContainer);
                     previewModalEl.addEventListener('hidden.bs.modal', () => {
                        try { wmContainer.remove(); } catch (e) { }
                     }, {once: true});
                  }
               };

               video.addEventListener('play', () => {
                  try {
                     const msg = watermarkMessage || `${sessionKey || ''}`;
                     createFourTextWatermarks(sessionKey, msg);
                  } catch (e) { /* ignore */ }
               });

               const onPreviewEndCleanup = () => {
                  try {
                     if (playStartTs) accumulatedSec += (Date.now() - playStartTs) / 1000;
                     playStartTs = 0;
                     stopHeartbeat();
                     const finalPos = Math.max(0, lastKnownPosition || Math.floor(video.currentTime || 0));
                     sendReadingEvent({action: 'preview_end', position: Math.floor(finalPos)}, true);
                  } catch (e) { /* ignore */ }
               };

               const modalHiddenHandler = () => {
                  if (modalClosed) return;
                  modalClosed = true;
                  try {
                     onPreviewEndCleanup();
                     try { progressWrap.removeEventListener('pointerdown', onPointerDown); } catch { }
                     try { window.removeEventListener('pointermove', onPointerMove); } catch { }
                     try { window.removeEventListener('pointerup', onPointerUp); } catch { }
                     try { window.removeEventListener('pointercancel', onPointerUp); } catch { }
                     try { progressWrap.removeEventListener('mousedown', onPointerDown); } catch { }
                     try { window.removeEventListener('mousemove', onPointerMove); } catch { }
                     try { window.removeEventListener('mouseup', onPointerUp); } catch { }
                     try { progressWrap.removeEventListener('touchstart', onPointerDown); } catch { }
                     try { window.removeEventListener('touchmove', onPointerMove); } catch { }
                     try { window.removeEventListener('touchend', onPointerUp); } catch { }
                     try { window.removeEventListener('touchcancel', onPointerUp); } catch { }
                     try { progressWrap.removeEventListener('click', onClickProgress); } catch { }
                     try { video.removeEventListener('timeupdate', onTimeUpdateHandler); } catch { }
                     try { video.removeEventListener('play', onPlayHandler); } catch { }
                     try { video.removeEventListener('pause', onPauseHandler); } catch { }
                     try { if (playBtn && playBtn.__playHandler) playBtn.removeEventListener('click', playBtn.__playHandler); } catch { }
                     try { if (pauseBtn && pauseBtn.__pauseHandler) pauseBtn.removeEventListener('click', pauseBtn.__pauseHandler); } catch { }
                     try { progressWrap.remove(); } catch { }
                     try {
                        video.pause();
                        video.removeAttribute('src');
                        video.load();
                     } catch (e) { console.warn('video cleanup error', e); }
                  } catch (e) { console.warn('modalHiddenHandler cleanup error', e); }
                  resolve(true);
               };

               previewModalEl.removeEventListener('hidden.bs.modal', modalHiddenHandler);
               previewModalEl.addEventListener('hidden.bs.modal', modalHiddenHandler, {once: true});

               const beforeUnloadHandler = () => {
                  try {
                     const payload = JSON.stringify({
                        user_id: window?.userId || null,
                        content_id: contentId,
                        session_key: sessionKey,
                        is_preview: true,
                        action: 'preview_end',
                        position: Math.max(0, lastKnownPosition || Math.floor(video.currentTime || 0)),
                        ts: Date.now()
                     });
                     const blob = new Blob([payload], {type: 'application/json'});
                     navigator.sendBeacon('/content-mgmt/api/reading-stats', blob);
                  } catch (e) { }
               };
               window.removeEventListener('beforeunload', beforeUnloadHandler);
               window.addEventListener('beforeunload', beforeUnloadHandler);

               setTimeout(() => {
                  try {
                     setProgressBarFromVideo();
                     updateTimeInfo();
                     updateLastKnownPosition(video.currentTime || 0);
                  } catch (e) { }
               }, 100);

               try {
                  const modalInstance = new bootstrap.Modal(previewModalEl, {backdrop: 'static'});
                  modalInstance.show();
                  previewModalEl.addEventListener('shown.bs.modal', () => {
                     try {
                        const firstBtn = previewModalEl.querySelector('button.rbt-btn');
                        if (firstBtn) firstBtn.focus();
                     } catch { }
                     video.play().catch(() => {
                     });
                  }, {once: true});
               } catch { previewModalEl.classList.add('show'); }

            } catch (err) {
               try {
                  Swal.fire({
                     icon: 'error',
                     title: window.t?.('contentmgr.preview_failed') || 'Preview failed',
                     text: String(err)
                  });
               } catch { }
               reject(err);
            }
         });
      };

      const openHtmlPreviewModal = async (contentId) => {
         const previewModalEl = document.getElementById("contentPreviewModal");
         const previewContainer = document.getElementById("previewContainer");
         if (!previewModalEl || !previewContainer) return;

         // fetch content (best-effort)
         let data = {};
         try {
            const res = await fetch(`/content-mgmt/api/contents/${encodeURIComponent(contentId)}`);
            if (res && res.ok) {
               const json = await res.json().catch(() => null);
               data = json?.data || {};
            }
         } catch (e) { /* ignore */ }

         // determine preferred language
         const isChinese = typeof window.lang !== "undefined" && window.lang === "zh-HK";
         const primaryHtml = isChinese ? (data.html_c || "") : (data.html_e || "");
         const secondaryHtml = isChinese ? (data.html_e || "") : (data.html_c || "");

         // build modal UI: title + one or two blocks; each block scrollable and limited height
         previewContainer.innerHTML = `
    <div class="html-preview-wrapper" style="display:flex;flex-direction:column;gap:10px;max-height:80vh;overflow:hidden;padding:12px;background:#fff;">
      <h5 style="margin:0 0 6px 0;font-weight:600;">${(isChinese ? (data.title_c || data.title_e) : (data.title_e || data.title_c)) || ""}</h5>

      <div class="html-preview-block primary" style="background:#ffffff;border:1px solid #eee;padding:10px;border-radius:6px;overflow:auto;max-height:calc(80vh * 0.6);">
        <span style="display:inline-block;font-size:13px;color:#334;border-radius:99px;background:#eef6ff;padding:6px 8px;font-weight:600;letter-spacing:0.2px;">
            ${isChinese ? "" : "English"}
        </span>
        <div id="htmlPreviewPrimary" style="min-height:120px;"></div>
      </div>

      ${secondaryHtml ? `
        <div class="html-preview-block secondary" style="background:#fbfdff;border:1px solid #e8f0ff;padding:10px;border-radius:6px;overflow:auto;max-height:calc(80vh * 0.35);">
            <span style="display:inline-block;font-size:13px;color:#334;border-radius:99px;background:#eef6ff;padding:6px 8px;font-weight:600;letter-spacing:0.2px;">
                ${isChinese ? "English" : ""}
            </span>
          <div id="htmlPreviewSecondary" style="min-height:80px;"></div>
        </div>
      ` : ""}
    </div>
  `;
         // inject content safely
         const setHtmlSafely = (el, html) => {
            if (!el) return;
            try {
               // we intentionally render stored HTML; server-side should sanitize on save
               el.innerHTML = html || "<em>No preview available</em>";
            } catch (e) {
               el.textContent = html || "";
            }
         };

         const primaryEl = document.getElementById("htmlPreviewPrimary");
         setHtmlSafely(primaryEl, primaryHtml || secondaryHtml || "<em>No preview available</em>");

         if (secondaryHtml) {
            const secondaryEl = document.getElementById("htmlPreviewSecondary");
            // only set secondary if it's not identical to primary to avoid duplication
            if (secondaryHtml !== primaryHtml) setHtmlSafely(secondaryEl, secondaryHtml);
            else if (secondaryEl) secondaryEl.innerHTML = "<em>Same content as above</em>";
         }

         try {
            const modal = new bootstrap.Modal(previewModalEl, {backdrop: "static"});
            modal.show();
         } catch (e) {
            previewModalEl.classList.add("show");
         }
      };

      // expose video preview helper globally if needed
      try { window.openVideoPreviewModal = openVideoPreviewModal; } catch (e) { /* ignore */ }
   });

})();
//--- END ---

//--- FILE: mgmt_user.js ---

const updateTabulatorColumnTitles = (table, titleMap) => {
   try {
      if (!table || typeof table.getColumns !== "function") return;
      table.getColumns().forEach(col => {
         try {
            const field = col.getField();
            if (!field) return;
            const newTitle = titleMap[field];
            if (typeof newTitle === "string" && newTitle.length > 0) col.updateDefinition({title: newTitle});
         } catch {
         }
      });
      try {
         table.redraw(true);
      } catch {
         try {
            table.replaceData();
         } catch {
         }
      }
   } catch (e) {
      console.warn("updateTabulatorColumnTitles failed", e);
   }
};

document.addEventListener("DOMContentLoaded", () => {

   let currentSearchQuery = "";

   // Ensure a global modal opener exists early so cellClick can call it
   if (typeof window.openUserModal !== "function") {
      window.openUserModal = (rowData) => {
         window.dispatchEvent(new CustomEvent("openUserModal", {detail: rowData ?? null}));
      };
   }

   const $groupSelect = (window.jQuery && window.jQuery("#editGroups")) || null;

   const initGroupSelect2 = (placeholderText) => {
      if (!$groupSelect) return;
      try {
         // preserve current value
         const prevVal = $groupSelect.val();
         // destroy only if already initialised
         if ($groupSelect.data("select2")) {
            try {
               $groupSelect.select2("destroy");
            } catch (_) {
            }
         }
         // init with translated placeholder
         $groupSelect.select2({
            placeholder: placeholderText,
            allowClear: true,
            tags: false,
            width: "100%"
         });
         // restore previous value (if any)
         try {
            $groupSelect.val(prevVal).trigger("change");
         } catch (_) {
         }
      } catch (e) {
         console.warn("initGroupSelect2 failed", e);
      }
   };
   const ensureSelect2 = () => {
      const placeholder = (typeof window.t === "function") ? window.t("usermgr.select_groups") : "Select groups";
      try {
         // Use initGroupSelect2 if available (preferred)
         if (typeof initGroupSelect2 === "function") {
            initGroupSelect2(placeholder);
            return;
         }
         // Fallback: single-shot initialization without destroying existing instance
         if ($groupSelect && typeof $groupSelect.select2 === "function" && !$groupSelect.data("select2")) {
            try {
               $groupSelect.select2({
                  placeholder,
                  allowClear: true,
                  tags: false,
                  width: "100%"
               });
            } catch (e) { /* ignore */ }
         } else {
            // If already initialised, update placeholder text safely
            try {
               if ($groupSelect && $groupSelect.data("select2")) {
                  const instance = $groupSelect.data("select2");
                  if (instance && instance.$container) {
                     const phEl = instance.$container.find(".select2-selection__placeholder");
                     if (phEl && phEl.length) phEl.text(placeholder);
                  }
               }
            } catch (e) { /* ignore */ }
         }
      } catch (e) { console.warn("ensureSelect2 failed", e); }
   };

   initGroupSelect2(typeof window.t === "function" ? window.t("usermgr.select_groups") : "Select groups");

   document.addEventListener("translations:ready", () => {
      const ph = typeof window.t === "function" ? window.t("usermgr.select_groups") : "Select groups";
      initGroupSelect2(ph);
   });


   // --- modal instance (single) ---
   const modalEl = document.getElementById("userEditModal");
   const modalInstance = (modalEl && window.bootstrap && typeof window.bootstrap.Modal === "function")
      ? new window.bootstrap.Modal(modalEl, {backdrop: "static", keyboard: false})
      : null;

   // --- group loader helper ---
   const loadAllGroups = async () => {
      try {
         const res = await fetch("/user-mgmt/api/groups?page=1&size=10000");
         if (!res.ok) return [];
         const json = await res.json();
         return Array.isArray(json.data) ? json.data : [];
      } catch (e) {
         console.warn("loadAllGroups failed", e);
         return [];
      }
   };

   // --- populate group select safely ---
   const populateGroupOptions = (allGroups, selectedIds) => {
      if (!$groupSelect) return;
      try {
         $groupSelect.find("option").remove();
         allGroups.forEach(g => {
            const id = String(g.group_id ?? "");
            const text = String(g.name_e ?? "");
            const option = new Option(text, id, false, selectedIds.includes(id));
            $groupSelect.append(option);
         });
         // notify select2
         try {
            $groupSelect.trigger("change");
         } catch {
         }
      } catch (e) {
         console.warn("populateGroupOptions failed", e);
      }
   };

   // --- openUserModal event: populate fields and show modal ---
   window.addEventListener("openUserModal", async (ev) => {
      const row = (ev && ev.detail) || {};
      // populate fields (try/catch each to avoid breaking)
      try {
         document.getElementById("editUserId").value = row.user_id || "";
      } catch {
      }
      try {
         document.getElementById("editEmployeeId").value = row.employee_id || "";
      } catch {
      }
      try {
         document.getElementById("editLastNameEnglish").value = row.last_name_english || "";
      } catch {
      }
      try {
         document.getElementById("editNameEnglish").value = row.name_english || "";
      } catch {
      }
      try {
         document.getElementById("editOtherNameEnglish").value = row.other_name_english || "";
      } catch {
      }
      try {
         document.getElementById("editLastNameChinese").value = row.last_name_chinese || "";
      } catch {
      }
      try {
         document.getElementById("editNameChinese").value = row.name_chinese || "";
      } catch {
      }
      try {
         document.getElementById("editEmail").value = row.email || "";
      } catch {
      }
      try {
         document.getElementById("editPhone").value = row.phone || "";
      } catch {
      }
      try {
         document.getElementById("editLastLogin").value = row.last_login || "";
      } catch {
      }
      try {
         document.getElementById("editCeaseEmployment").value = row.cease_employment_effective_date || "";
      } catch {
      }

      // roles display
      try {
         const roleDisplay = document.getElementById("editTmsRoleDisplay");
         if (roleDisplay) {
            roleDisplay.innerHTML = "";
            const roles = (typeof row.tms_role === "string" && row.tms_role.trim()) ? JSON.parse(row.tms_role) : (Array.isArray(row.tms_role) ? row.tms_role : []);
            (roles || []).forEach(r => {
               const s = document.createElement("span");
               s.className = "badge bg-secondary text-white px-3 py-2 fs-6 me-1";
               s.textContent = String(r);
               roleDisplay.appendChild(s);
            });
         }
      } catch (e) {
         console.warn("role display failed", e);
      }

      // groups: load all and map selected
      try {
         ensureSelect2();
         const allGroups = await loadAllGroups();
         let selectedIds = [];
         if (Array.isArray(row.groups) && row.groups.length && row.groups.every(g => /^[0-9]+$/.test(String(g)))) {
            selectedIds = row.groups.map(g => String(g));
         } else if (Array.isArray(row.groups) && row.groups.length) {
            const byName = new Map(allGroups.map(g => [String(g.name_e), String(g.group_id)]));
            selectedIds = row.groups.map(n => byName.get(String(n))).filter(Boolean).map(String);
         } else if (typeof row.groups === "string" && row.groups.trim()) {
            try {
               const parsed = JSON.parse(row.groups);
               if (Array.isArray(parsed)) {
                  if (parsed.length && parsed.every(g => /^[0-9]+$/.test(String(g)))) selectedIds = parsed.map(g => String(g));
                  else {
                     const byName = new Map(allGroups.map(g => [String(g.name_e), String(g.group_id)]));
                     selectedIds = parsed.map(n => byName.get(String(n))).filter(Boolean).map(String);
                  }
               }
            } catch {
            }
         }
         populateGroupOptions(allGroups, selectedIds);
         // set values in select2 after DOM stable
         setTimeout(() => {
            try {
               $groupSelect && $groupSelect.val(selectedIds).trigger("change");
            } catch {
            }
         }, 60);
      } catch (e) {
         console.warn("groups handling failed", e);
      }

      // show modal safely
      try {
         if (modalInstance && typeof modalInstance.show === "function") modalInstance.show();
         else if (window.jQuery) try {
            window.jQuery(modalEl).modal("show");
         } catch {
         }
      } catch (e) {
         console.warn("show modal failed", e);
      }
   });

   // --- modal save & close wiring ---
   try {
      const formEl = document.getElementById("userEditForm");
      const confirmBtn = document.getElementById("confirmEditUser");
      const closeBtn = document.getElementById("closeUserModal");
      if (confirmBtn && formEl) {
         confirmBtn.addEventListener("click", async () => {
            try {
               const fd = new FormData(formEl);
               const payload = Object.fromEntries(fd.entries());
               const selected = ($groupSelect && $groupSelect.val()) || [];
               payload.groups = Array.isArray(selected) ? selected.map(v => Number(v)) : [];

               const userId = payload.user_id;
               const res = await fetch(`/user-mgmt/api/users/${encodeURIComponent(userId)}`, {
                  method: "PUT",
                  headers: {"Content-Type": "application/json"},
                  body: JSON.stringify(payload)
               });
               if (res.ok) {
                  try {
                     window.userTable.replaceData();
                  } catch {
                     try {
                        window.userTable.setData();
                     } catch {
                     }
                  }
                  if (modalInstance && typeof modalInstance.hide === "function") modalInstance.hide();
                  else if (window.jQuery) try {
                     window.jQuery(modalEl).modal("hide");
                  } catch {
                  }
               } else {
                  const txt = await res.text().catch(() => "");
                  alert((window.t ? window.t("usermgr.failed_to_update_user") : "Failed to update user") + (txt ? ": " + txt : ""));
               }
            } catch (e) {
               console.error("update user failed", e);
            }
         });
      }
      if (closeBtn) closeBtn.addEventListener("click", () => {
         if (modalInstance) modalInstance.hide(); else if (window.jQuery) try {
            window.jQuery(modalEl).modal("hide");
         } catch {
         }
      });
   } catch (e) {
      console.warn("modal wiring failed", e);
   }

   // --- TABULATOR TABLE (remote pagination) ---
   const userTableEl = document.getElementById("userTable");
   if (!userTableEl) return;

   const table = new Tabulator(userTableEl, {
      ajaxURL: "/user-mgmt/api/users",
      ajaxConfig: "GET",
      layout: "fitDataStretch",
      pagination: true,
      paginationMode: "remote", // server side
      paginationSize: 10,
      paginationSizeSelector: [5, 10, 25, 50, 100, true],
      paginationButtonCount: 4,
      placeholder: window.t ? window.t("usermgr.no_user_found") : "No users found",
      index: "user_id",
      locale: window.lang,
      paginationDataSent: {page: "page", size: "size"},
      ajaxURLGenerator: (url, _config, params) => {
         const qp = new URLSearchParams();
         qp.set("page", params.page);
         qp.set("size", params.size);
         if (typeof currentSearchQuery === "string" && currentSearchQuery.trim() !== "") qp.set("keyword", currentSearchQuery.trim());
         return `${url}?${qp.toString()}`;
      },
      ajaxResponse: (_url, params, response) => {
         // defensive: server might return array OR {data:[], page, last_page, total}
         // If response is array, treat as data with page=1
         const isArray = Array.isArray(response);
         const data = isArray ? response : (Array.isArray(response.data) ? response.data : []);
         const page = isArray ? (params.page || 1) : (response.page ?? params.page ?? 1);
         const total = isArray ? data.length : Number(response.total ?? 0);
         const last_page = isArray ? Math.max(1, Math.ceil(total / (params.size || data.length || 1))) : (response.last_page ?? Math.max(1, Math.ceil(total / (params.size || 1))));
         return {data, page, last_page, total};
      },
      langs: {
         [window.lang]: {
            pagination: {
               first: window.t ? window.t("pagination.first") : "First",
               last: window.t ? window.t("pagination.last") : "Last",
               prev: window.t ? window.t("pagination.prev") : "Prev",
               next: window.t ? window.t("pagination.next") : "Next",
               page_size: window.t ? window.t("pagination.page_size") : "Page size"
            }
         }
      },
      columns: [
         {
            title: "",
            field: "actions",
            hozAlign: "center",
            headerSort: false,
            width: 45,
            formatter: () => `<div class="icon-wrapper"><img src="/assets/images/icons/edit.svg" class="edit-icon" title="${window.t ? window.t('usermgr.edit_user') : 'Edit'}"></div>`,
            cellClick: (e, cell) => {
               try {
                  const rowData = cell.getRow().getData(); // reliable under remote paging
                  if (typeof window.openUserModal === "function") window.openUserModal(rowData);
               } catch (err) {
                  console.warn("cellClick error", err);
               }
            }
         },
         {
            title: window.t ? window.t("usermgr.user_id") : "User ID",
            field: "user_id",
            width: 150,
            headerSort: false
         },
         {
            title: window.t ? window.t("usermgr.en_name") : "English Name",
            field: "name_english",
            width: 180,
            headerSort: false
         },
         {
            title: window.t ? window.t("usermgr.ch_name") : "Chinese Name",
            field: "name_chinese",
            width: 150,
            headerSort: false
         },
         {title: window.t ? window.t("usermgr.email") : "Email", field: "email", width: 200, headerSort: false},
         {title: window.t ? window.t("usermgr.phone") : "Phone", field: "phone", width: 120, headerSort: false},
         {
            title: window.t ? window.t("usermgr.groups") : "Groups",
            field: "groups",
            formatter: cell => {
               const groups = Array.isArray(cell.getValue()) ? cell.getValue() : [];
               return groups.map(g => `<span class="badge bg-info text-dark px-2 py-1 me-1">${g}</span>`).join("");
            }
         }
      ]
   });

   window.userTable = table;

   // tableBuilt: footer layout and translation-friendly retries
   table.on("tableBuilt", () => {
      try {
         const footer = userTableEl.querySelector(".tabulator-footer");
         if (!footer) return;
         if (!footer.querySelector(".tabulator-footer-left")) {
            const paginationControls = footer.querySelector(".tabulator-paginator");
            const leftDiv = document.createElement("div");
            leftDiv.className = "tabulator-footer-left d-flex align-items-center";
            const rightDiv = document.createElement("div");
            rightDiv.className = "tabulator-footer-right d-flex align-items-center";
            if (paginationControls) rightDiv.appendChild(paginationControls);
            const addBtnWrapper = document.getElementById("btnAddUserWrapper");
            if (addBtnWrapper) leftDiv.appendChild(addBtnWrapper);
            footer.innerHTML = "";
            footer.appendChild(leftDiv);
            footer.appendChild(rightDiv);
         } else {
            const left = footer.querySelector(".tabulator-footer-left");
            const addBtnWrapper = document.getElementById("btnAddUserWrapper");
            if (left && addBtnWrapper && !left.contains(addBtnWrapper)) left.insertBefore(addBtnWrapper, left.firstChild);
         }

         // update column titles
         const titleMap = {
            user_id: window.t ? window.t("usermgr.user_id") : "User ID",
            name_english: window.t ? window.t("usermgr.en_name") : "English Name",
            name_chinese: window.t ? window.t("usermgr.ch_name") : "Chinese Name",
            email: window.t ? window.t("usermgr.email") : "Email",
            phone: window.t ? window.t("usermgr.phone") : "Phone",
            groups: window.t ? window.t("usermgr.groups") : "Groups"
         };
         updateTabulatorColumnTitles(table, titleMap);

         // run pager translation (safe)
         translatePagerSizeTexts("#userTable");
         setTimeout(() => translatePagerSizeTexts("#userTable"), 120);
      } catch (e) {
         console.warn("tableBuilt handler failed", e);
      }
   });

   // translate pager + fix select (copied safe logic)
   function translatePagerSizeTexts(tableSelector = "#userTable") {
      const tx = k => (typeof window.t === "function" ? window.t(k) : k);
      try {
         const tableEl = document.querySelector(tableSelector);
         if (!tableEl) return;
         const footer = tableEl.querySelector(".tabulator-footer");
         if (!footer) return;
         const paginator = footer.querySelector(".tabulator-paginator") || footer;

         [
            {sel: '[data-page="first"]', key: "pagination.first"},
            {sel: '[data-page="prev"]', key: "pagination.prev"},
            {sel: '[data-page="next"]', key: "pagination.next"},
            {sel: '[data-page="last"]', key: "pagination.last"}
         ].forEach(m => {
            const btn = paginator.querySelector(m.sel) || paginator.querySelector(`button[aria-label*="${m.key.split('.').pop()}"]`);
            if (!btn) return;
            const v = tx(m.key);
            if ((btn.textContent || "").trim() !== v) btn.textContent = v;
            btn.title = v;
            btn.setAttribute("aria-label", v);
         });

         const sizeLabel = paginator.querySelector(".tabulator-page-size-text, .tabulator-page-size-label, label");
         if (sizeLabel) {
            const v = tx("pagination.page_size");
            if ((sizeLabel.textContent || "").trim() !== v) sizeLabel.textContent = v;
         }

         const sizeSelect = paginator.querySelector("select.tabulator-page-size, select");
         if (sizeSelect) {
            const allText = (tx("pagination.all") && tx("pagination.all") !== "pagination.all") ? tx("pagination.all") : tx("pagination.page_size");
            Array.from(sizeSelect.options || []).forEach(opt => {
               const val = String(opt.value || "").trim().toLowerCase();
               if (val === "" || val === "all" || val === "true" || /(all)/i.test(opt.text || "")) {
                  if (opt.text !== allText) opt.text = allText;
               } else {
                  const n = Number(val);
                  if (Number.isFinite(n) && (opt.text.trim() !== String(n))) opt.text = String(n);
               }
            });
            const label = tx("pagination.page_size");
            if ((sizeSelect.title || "") !== label) sizeSelect.title = label;
            if ((sizeSelect.getAttribute("aria-label") || "") !== label) sizeSelect.setAttribute("aria-label", label);
         }
      } catch (e) {
         console.warn("translatePagerSizeTexts failed", e);
      }
   }

   // schedule translator runs
   (function paginatorTranslatorScheduler() {
      let timer = 0;
      const scheduleRun = (delay = 60) => {
         clearTimeout(timer);
         timer = setTimeout(() => translatePagerSizeTexts("#userTable"), delay);
      };
      try {
         if (window.userTable && typeof window.userTable.on === "function") window.userTable.on("tableBuilt", () => scheduleRun(80));
      } catch {
      }
      document.addEventListener("translations:ready", () => scheduleRun(120));
      document.addEventListener("DOMContentLoaded", () => scheduleRun(160));
      window.applyUserTranslations = () => scheduleRun(0);
   })();

   // search wiring: update keyword and go to page 1 (server will use keyword param)
   const searchEl = document.getElementById("userSearch");
   if (searchEl) {
      searchEl.addEventListener("input", function () {
         currentSearchQuery = this.value.trim().toLowerCase();
         try {
            table.setPage(1);
         } catch {
         }
      });
   }

});
//--- END ---

//--- FILE: mgmt_usergroup.js ---

document.addEventListener("DOMContentLoaded", () => {

   // HTML escape helper used across formatters and assign modal
   function escapeHtml(str) {
      return String(str || "")
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
   }

   let currentSearchQuery = "";
   const isChinese = window.lang === "zh-HK";

   const apiCall = async (url, method = "GET", payload = null) => {
      try {
         const options = {
            method,
            headers: {"Content-Type": "application/json"},
            body: payload ? JSON.stringify(payload) : null
         };
         const res = await fetch(url, options);
         if (!res.ok) {
            console.error(`API error: ${res.statusText}`);
            return {success: false, error: res.statusText};
         }
         return await res.json();
      } catch (err) {
         console.error("API call failed:", err);
         return {success: false, error: err.message};
      }
   };

   const parseJSON = input => {
      try {
         if (typeof input === "string") {
            return JSON.parse(input);
         }
         return Array.isArray(input) ? input : [];
      } catch {
         return [];
      }
   };

   const createTabulatorTable = (el, config) => new Tabulator(el, config);

   // ========== USER GROUP TABLE ==========
   const initGroupTable = () => {

      const el = document.getElementById("userGroupTable");
      if (!el) return;

      const showGroupModal = (callback, data = {}, title = `${window.t("usergroup.create_grp")}`) => {
         const modalEl = document.getElementById("addGroupModal");
         const modal = bootstrap.Modal.getOrCreateInstance(modalEl, {
            backdrop: 'static',
            keyboard: false
         });
         modalEl.querySelector("#addGroupLabel").textContent = title;

         const nameInput = modalEl.querySelector("#groupNameInput");
         const descInput = modalEl.querySelector("#groupDescInput");
         const nameInputC = modalEl.querySelector("#groupNameInputC");
         const descInputC = modalEl.querySelector("#groupDescInputC");
         nameInput.value = data.name_e || "";
         descInput.value = data.desc_e || "";
         nameInputC.value = data.name_c || "";
         descInputC.value = data.desc_c || "";

         const confirmBtn = modalEl.querySelector("#confirmCreateGroup");
         if (confirmBtn) {
            confirmBtn.onclick = async () => {
               const name_e = nameInput.value.trim();
               const name_c = nameInputC.value.trim();
               const desc_e = descInput.value.trim();
               const desc_c = descInputC.value.trim();

               if (!name_e || !name_c || !desc_e) {
                  return Swal.fire({
                     icon: "warning",
                     title: window.t("usergroup.missing_fields"),
                     text: window.t("usergroup.fill_in_both_name")
                  });
               }

               await callback({name_e, desc_e, name_c, desc_c}, {
                  hide: () => modal.hide()
               });
            };
         }

         modal.show();
         modalEl.removeAttribute("aria-hidden");
      };

      const handleAdd = () => showGroupModal(async (formData, modal) => {
         const res = await apiCall("/user-mgmt/api/creategroup", "POST", formData);
         if (res.success) {
            groupTable.replaceData();
            Swal.fire({
               icon: "success",
               title: window.t("usergroup.created"),
               text: `"${formData.name_e}" ${window.t("usergroup.added")}`
            });
            modal.hide();
         } else {
            Swal.fire({
               icon: "error",
               title: window.t("usergroup.creation_failed"),
               text: res.error || `${window.t("usergroup.unable_to_create_group")}`
            });
         }
      });

      const handleEdit = rowData => {
         if (!rowData?.group_id) {
            return Swal.fire({
               icon: "error",
               title: window.t("usergroup.edit_failed"),
               text: window.t("usergroup.missing_group_id")
            });
         }
         showGroupModal(async (formData, modal) => {
            const res = await fetch(`/user-mgmt/api/groups/${rowData.group_id}`, {
               method: "PUT",
               credentials: "include",
               headers: {"Content-Type": "application/json"},
               body: JSON.stringify(formData)
            });
            const result = await res.json();

            if (result.success) {
               groupTable.replaceData();
               Swal.fire({
                  icon: "success",
                  title: window.t("usergroup.success"),
                  text: `"${formData.name_e}" ${window.t("usergroup.updated")}`
               });
               modal.hide();
            } else {
               Swal.fire({
                  icon: "error",
                  title: window.t("usergroup.failed"),
                  text: result.error || `${window.t("usergroup.unable_to_save_changes")}`
               });
            }
         }, rowData, "Edit Group");
      };

      // Remote pagination/search (pattern from mgmt_category)
      const ajaxURLGenerator = (url, config, params) => {
         const qp = new URLSearchParams();
         qp.set("page", params.page || 1);
         qp.set("size", params.size || 10);
         if (typeof currentSearchQuery === "string" && currentSearchQuery.trim() !== "") qp.set("keyword", currentSearchQuery.trim());
         if (Array.isArray(params.sorters) && params.sorters.length) qp.set("sorters", JSON.stringify(params.sorters));
         if (Array.isArray(params.filters) && params.filters.length) qp.set("filters", JSON.stringify(params.filters));
         return `${url}?${qp.toString()}`;
      };

      const ajaxResponse = (url, params, response) => {
         const currentPage = response.page ?? params.page;
         const lastPage = response.last_page ?? Math.max(1, Math.ceil((response.total ?? 0) / (params.size || 1)));
         return {
            data: Array.isArray(response.data) ? response.data : [],
            page: currentPage,
            last_page: lastPage,
            total: Number(response.total ?? 0)
         };
      };

      const groupTable = createTabulatorTable(el, {
         ajaxURL: "/user-mgmt/api/groups",
         ajaxConfig: "GET",
         ajaxURLGenerator,
         ajaxResponse,
         layout: "fitDataStretch",
         pagination: true,
         paginationMode: "remote",
         paginationSize: 10,
         paginationSizeSelector: [10, 25, 50, 100, true],
         paginationButtonCount: 4,
         placeholder: window.t("usergroup.no_groups_found"),
         index: "group_id",
         locale: window.lang,
         paginationDataSent: {page: "page", size: "size"},
         langs: {
            [window.lang]: {
               pagination: {
                  first: window.t("pagination.first"),
                  last: window.t("pagination.last"),
                  prev: window.t("pagination.prev"),
                  next: window.t("pagination.next"),
                  page_size: window.t("pagination.page_size")
               }
            }
         },
         columns: [
            {
               title: "", field: "action", hozAlign: "center", headerSort: false, width: 80,
               formatter: () => `
            <div class="icon-wrapper text-center">
              <img src="/assets/images/icons/trash.svg" class="trash-icon">
              <img src="/assets/images/icons/edit.svg" class="edit-icon">
            </div>
            `,
               cellClick: async (e, cell) => {
                  const rowData = cell.getRow().getData();
                  const target = e.target;

                  if (target.classList.contains("edit-icon")) return handleEdit(rowData);

                  if (target.classList.contains("trash-icon")) {
                     const verifyRes = await fetch(`/user-mgmt/api/groups/${rowData.group_id}/users`);
                     const data = await verifyRes.json();

                     if (Array.isArray(data.assigned) && data.assigned.length > 0) {
                        return Swal.fire({
                           icon: "warning",
                           title: window.t("usergroup.cannot_delete"),
                           text: `${window.t("usergroup.group")} "${rowData.name}" ${window.t("usergroup.is_assigned")}`
                        });
                     }

                     Swal.fire({
                        icon: "warning",
                        title: window.t("usergroup.del_group?"),
                        text: `${window.t("usergroup.delete")} "${rowData.name_e}"?`,
                        showCancelButton: true,
                        confirmButtonText: `${window.t("usergroup.yes")}`,
                        cancelButtonText: `${window.t("usergroup.cancel")}`
                     }).then(async result => {
                        if (result.isConfirmed) {
                           const deleteRes = await fetch(`/user-mgmt/api/groups/${rowData.group_id}`, {
                              method: "DELETE"
                           });
                           const resultData = await deleteRes.json();

                           if (resultData.success) {
                              cell.getRow().delete();
                              Swal.fire({
                                 icon: "success",
                                 title: window.t("usergroup.deleted"),
                                 text: `"${rowData.name}" ${window.t("usergroup.was_removed")}`
                              });
                           } else {
                              Swal.fire({
                                 icon: "error",
                                 title: window.t("usergroup.delete_failed"),
                                 text: resultData.error || window.t("usergroup.delete_failed")
                              });
                           }
                        }
                     });
                  }
               }
            },
            {
               title: isChinese ? window.t("usergroup.group_name_c") : window.t("usergroup.group_name_e"),
               field: isChinese ? "name_c" : "name_e",
               headerSort: true
            },
            {
               title: isChinese ? window.t("usergroup.desc_c") : window.t("usergroup.desc_e"),
               field: isChinese ? "desc_c" : "desc_e",
               headerSort: true
            },
            {
               title: window.t("usergroup.users"),
               field: "users",
               formatter: (cell) => {
                  const raw = cell.getValue();
                  const users = Array.isArray(raw) ? raw : [];
                  const groupId = cell.getRow().getData().group_id;
                  const maxVisible = 6;
                  const query = window.currentSearchQuery?.toLowerCase() || "";

                  let html = `<span class="badge bg-primary text-white me-1 mb-1 px-3 py-2 assign-users" data-group-id="${groupId}" style="cursor:pointer;">${window.t("usergroup.assign")}</span>`;

                  users.slice(0, maxVisible).forEach(user => {
                     const name = typeof user === "object" ? user.name ?? "Unknown" : String(user);
                     const lowerName = name.toLowerCase();
                     const match = query && lowerName.includes(query);

                     const badgeClass = match ? "highlighted-user" : "bg-secondary text-white";
                     html += `<span class="badge ${badgeClass} me-1 mb-1 px-3 py-2">${escapeHtml(name)}</span>`;
                  });

                  if (users.length > maxVisible) {
                     const remaining = users.length - maxVisible;
                     html += `<span class="badge bg-warning me-1 mb-1 view-more-users" data-group-id="${groupId}">+${remaining} more</span>`;
                  }
                  return html;
               },
               hozAlign: "left"
            }
         ]
      });
      window.groupTable = groupTable;

      // Footer setup
      setTimeout(() => {
         const footer = el.querySelector(".tabulator-footer");
         if (footer) {
            footer.classList.add("d-flex", "justify-content-between", "align-items-center", "px-3", "py-2");

            const leftDiv = document.createElement("div");
            const existingBtn = document.getElementById("addGroupBtnWrapper");
            if (existingBtn) {
               const btn = existingBtn.querySelector("#addGroupBtn");
               if (btn) leftDiv.appendChild(btn);
            }

            const paginator = footer.querySelector(".tabulator-paginator");
            footer.innerHTML = "";
            footer.appendChild(leftDiv);
            if (paginator) footer.appendChild(paginator);

            leftDiv.querySelector("#addGroupBtn")?.addEventListener("click", handleAdd);
         }
      }, 100);

      // Translate pager buttons and page-size texts (idempotent)
      const translatePagerSizeTexts = (tableSelector = "#userGroupTable") => {
         const tx = k => (typeof window.t === "function" ? window.t(k) : k);
         try {
            const tableElLocal = document.querySelector(tableSelector);
            if (!tableElLocal) return;
            const footer = tableElLocal.querySelector(".tabulator-footer");
            if (!footer) return;
            const paginator = footer.querySelector(".tabulator-paginator") || footer;

            [
               {sel: '[data-page="first"]', key: "pagination.first"},
               {sel: '[data-page="prev"]', key: "pagination.prev"},
               {sel: '[data-page="next"]', key: "pagination.next"},
               {sel: '[data-page="last"]', key: "pagination.last"}
            ].forEach(m => {
               const btn = paginator.querySelector(m.sel) || paginator.querySelector(`button[aria-label*="${m.key.split('.').pop()}"]`);
               if (!btn) return;
               const v = tx(m.key);
               if ((btn.textContent || "").trim() !== v) btn.textContent = v;
               btn.title = v;
               btn.setAttribute("aria-label", v);
            });

            const sizeSelect = paginator.querySelector("select.tabulator-page-size, select");
            if (sizeSelect) {
               const allText = (tx("pagination.all") && tx("pagination.all") !== "pagination.all") ? tx("pagination.all") : tx("pagination.page_size");
               Array.from(sizeSelect.options || []).forEach(opt => {
                  const val = String(opt.value || "").trim().toLowerCase();
                  if (val === "" || val === "all" || val === "true" || /(all)/i.test(opt.text || "")) {
                     if (opt.text !== allText) opt.text = allText;
                  } else {
                     const n = Number(val);
                     if (Number.isFinite(n) && (opt.text.trim() !== String(n))) opt.text = String(n);
                  }
               });
               const label = tx("pagination.page_size");
               if ((sizeSelect.title || "") !== label) sizeSelect.title = label;
               if ((sizeSelect.getAttribute("aria-label") || "") !== label) sizeSelect.setAttribute("aria-label", label);
            }
         } catch (e) {
            console.warn("translatePagerSizeTexts failed", e);
         }
      };

      // Search wiring: remote reload via setPage(1)
      const searchInput = document.getElementById("userGroupSearch");
      if (searchInput) {
         let timer = null;
         const triggerSearch = () => {
            currentSearchQuery = (searchInput.value || "").trim().toLowerCase();
            window.currentSearchQuery = currentSearchQuery;
            groupTable.setPage(1);
         };
         searchInput.addEventListener("input", () => {
            clearTimeout(timer);
            timer = setTimeout(triggerSearch, 300);
         });
         searchInput.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
               ev.preventDefault();
               clearTimeout(timer);
               triggerSearch();
            }
         });
      }

      // Redraw badges and translate pager on load/build
      try {
         groupTable.on("dataLoaded", () => {
            try { groupTable.redraw(true); } catch (e) {}
            translatePagerSizeTexts("#userGroupTable");
         });
         groupTable.on("tableBuilt", () => {
            translatePagerSizeTexts("#userGroupTable");
            setTimeout(() => translatePagerSizeTexts("#userGroupTable"), 120);
         });
      } catch (e) { }

      // View-more-users modal
      document.addEventListener("click", (e) => {
         if (e.target.classList.contains("view-more-users")) {
            const groupId = e.target.dataset.groupId;
            const modal = document.getElementById("assignedUsersModal");
            const modalBody = document.getElementById("assignedUsersTableBody");
            const searchInput = document.getElementById("assignedUserSearch");
            const pagination = document.getElementById("assignedUserPagination");

            if (!modal || !modalBody || !searchInput) {
               console.error("Modal elements not found");
               return;
            }
            modalBody.innerHTML = `
      <div class="text-center py-3">
        <div class="spinner-border text-primary"></div>
      </div>
    `;

            fetch(`/user-mgmt/api/groups/${groupId}/users`)
               .then(res => res.json())
               .then(data => {
                  const users = Array.isArray(data.assigned) ? data.assigned : [];
                  let filteredUsers = [...users];
                  let currentPageLocal = 1;
                  const perPage = 5;

                  const renderUsers = () => {
                     const start = (currentPageLocal - 1) * perPage;
                     const paginated = filteredUsers.slice(start, start + perPage);

                     modalBody.innerHTML = paginated.map(u => `
                                <tr>
                                    <td>
                                        <strong>${escapeHtml(u.name)}</strong><br/>
                                         <small class="text-muted">${escapeHtml(u.user_id)}</small>
                                    </td>
                                    </tr>
                                `).join("");
                     renderPagination();
                  };

                  const renderPagination = () => {
                     const totalPages = Math.ceil(filteredUsers.length / perPage);
                     if (totalPages <= 1) {
                        pagination.innerHTML = "";
                        return;
                     }

                     let html = `<ul class="pagination justify-content-center">`;

                     html += `
    <li class="page-item ${currentPageLocal === 1 ? 'disabled' : ''}">
      <button class="page-link" data-page="${currentPageLocal - 1}" style="width: 100px">${window.t("usergroup.btnPrevious")}</button>
    </li>
  `;

                     for (let i = 1; i <= totalPages; i++) {
                        html += `
      <li class="page-item ${i === currentPageLocal ? 'active' : ''}">
        <button class="page-link" data-page="${i}">${i}</button>
      </li>
    `;
                     }

                     html += `
    <li class="page-item ${currentPageLocal === totalPages ? 'disabled' : ''}">
      <button class="page-link" data-page="${currentPageLocal + 1}" style="width: 100px">${window.t("usergroup.btnNext")}</button>
    </li>
  `;

                     html += `</ul>`;
                     pagination.innerHTML = html;

                     pagination.querySelectorAll("button.page-link").forEach(btn => {
                        btn.addEventListener("click", () => {
                           const page = parseInt(btn.dataset.page);
                           if (!isNaN(page) && page >= 1 && page <= totalPages) {
                              currentPageLocal = page;
                              renderUsers();
                           }
                        });
                     });
                  };

                  searchInput.addEventListener("input", (ev) => {
                     const keyword = ev.target.value.toLowerCase();
                     filteredUsers = users.filter(u =>
                        u.name.toLowerCase().includes(keyword) ||
                        u.user_id.toLowerCase().includes(keyword)
                     );
                     currentPageLocal = 1;
                     renderUsers();
                  });

                  renderUsers();
                  bootstrap.Modal.getOrCreateInstance(modal).show();
               })
               .catch(err => {
                  modalBody.innerHTML = `<div class="text-danger">${window.t("msg.failed_to_ld_users")}</div>`;
                  console.error("Error fetching users:", err);
               });
         }
      });

      const userSearchEl = document.getElementById("userSearch");
      if (userSearchEl) {
         userSearchEl.addEventListener("input", (e) => {
            const query = e.target.value.toLowerCase();
            document.querySelectorAll("#unassignedUserTable tr").forEach(row => {
               const name = row.dataset.name.toLowerCase();
               row.style.display = name.includes(query) ? "" : "none";
            });
         });
      }
   };

   const assignedUserSearchEl = document.getElementById("assignedUserSearch");
   if (assignedUserSearchEl) {
      assignedUserSearchEl.addEventListener("input", (e) => {
         const keyword = e.target.value.toLowerCase();
         const rows = document.querySelectorAll("#assignedUsersTableBody tr");
         rows.forEach(row => {
            const text = row.textContent.toLowerCase();
            row.style.display = text.includes(keyword) ? "" : "none";
         });
      });
   }

   function renderAssignedUsers(users, page = 1, perPage = 5) {
      const modalBody = document.getElementById("assignedUsersModalBody");
      const pagination = document.getElementById("assignedUserPagination");

      const totalPages = Math.ceil(users.length / perPage);
      const start = (page - 1) * perPage;
      const paginatedUsers = users.slice(start, start + perPage);

      modalBody.innerHTML = paginatedUsers.map(u => `
    <div class="d-flex align-items-center mb-2">
      <div>
        <strong>${escapeHtml(u.name)}</strong><br/>
        <small class="text-muted">${escapeHtml(u.user_id)}</small>
      </div>
    </div>
  `).join("");

      pagination.innerHTML = Array.from({length: totalPages}, (_, i) => `
    <button class="btn btn-sm btn-outline-primary mx-1 ${i + 1 === page ? 'active' : ''}" data-page="${i + 1}">
      ${i + 1}
    </button>
  `).join("");

      pagination.querySelectorAll("button").forEach(btn => {
         btn.addEventListener("click", () => {
            renderAssignedUsers(users, parseInt(btn.dataset.page), perPage);
         });
      });
   }

   function renderPagination(currentPage, totalPages) {
      const pagination = document.getElementById("assignedUserPagination");
      if (!pagination) return;

      let html = '';

      html += `
    <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
      <button class="page-link" data-page="${currentPage - 1}" style="width: 100px">${window.t("usergroup.btnPrevious")}</button>
    </li>
  `;

      for (let i = 1; i <= totalPages; i++) {
         html += `
      <li class="page-item ${i === currentPage ? 'active' : ''}">
        <button class="page-link" data-page="${i}">${i}</button>
      </li>
    `;
      }

      html += `
    <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
      <button class="page-link" data-page="${currentPage + 1}" style="width: 100px">${window.t("usergroup.btnNext")}</button>
    </li>
  `;

      pagination.innerHTML = html;
   }

   // ========== ASSIGN USERS MODAL ==========
   const USERS_PER_PAGE = 10;
   let selectedGroupId = null;
   let originalUserList = [];
   let filteredUserList = [];
   let currentPage = 1;

   // Persist selection across pagination/filter
   let selectedUserIds = new Set();

   const openAssignUsersModal = (groupId) => {
      selectedGroupId = groupId;
      selectedUserIds = new Set();
      $('#assignUsersModal').modal('show');
      showLoadingSpinner();
      fetchGroupUsers(groupId);
   };

   const showLoadingSpinner = () => {
      $('#assignUserList').html(`
    <div class="text-center py-4">
      <div class="spinner-border text-primary" role="status"></div>
      <div class="mt-2">${window.t("global.Loading......")}</div>
    </div>
    `);
   };

   const fetchGroupUsers = (groupId) => {
      $.get(`/user-mgmt/api/groups/${groupId}/users`, (res) => {
         const assigned = (res.assigned || []).map(u => ({...u, assigned: true}));
         const unassigned = (res.unassigned || []).map(u => ({...u, assigned: false}));

         originalUserList = [...assigned, ...unassigned];
         selectedUserIds = new Set(assigned.map(u => String(u.user_id)));
         filteredUserList = [...originalUserList];
         currentPage = 1;
         renderUserTable();
      });
   };

   const renderUserTable = () => {
      const assignUserListEl = document.getElementById('assignUserList');
      if (!assignUserListEl) {
         console.error('assignUserList not found');
         return;
      }

      const start = (currentPage - 1) * USERS_PER_PAGE;
      const paginatedUsers = filteredUserList.slice(start, start + USERS_PER_PAGE);

      const rows = paginatedUsers.length
         ? paginatedUsers.map((user, index) => {
            const id = String(user.user_id);
            const checkedAttr = selectedUserIds.has(id) ? 'checked' : '';
            return `
                <tr data-name="${escapeHtml((user.name || '').toLowerCase())}">
                    <td class="checkbox-cell">
                        <input type="checkbox"
                               class="form-check-input user-checkbox me-1"
                               value="${escapeHtml(id)}"
                               id="user-${start + index}"
                               ${checkedAttr}>
                    </td>
                    <td>${escapeHtml(user.user_id)}</td>
                    <td>${escapeHtml(user.name)}</td>
                </tr>
            `;
         }).join('')
         : `<tr><td colspan="3" class="text-center">${window.t("no_users_found")}</td></tr>`;

      assignUserListEl.innerHTML = `
        <table class="table table-bordered table-hover">
            <thead>
                <tr>
                    <th class="checkbox-cell">
                        <input type="checkbox" id="selectAll" class="form-check-input me-1">
                    </th>
                    <th>${window.t("user_id")}</th>
                    <th>${window.t("name_e")}</th>
                </tr>
            </thead>
            <tbody>${rows}</tbody>
        </table>
    `;

      syncSelectAllHeader();
      renderPaginationControls();
   };

   const renderPaginationControls = () => {
      const totalPages = Math.ceil(filteredUserList.length / USERS_PER_PAGE);
      const paginationEl = $('#assignUserPagination');
      paginationEl.empty();

      if (totalPages <= 1) return;

      let buttons = '';

      buttons += `
        <button class="btn btn-sm btn-outline-secondary mx-1" data-page="${currentPage - 1}" ${currentPage === 1 ? 'disabled' : ''}>
            Prev
        </button>
    `;

      for (let i = 1; i <= totalPages; i++) {
         buttons += `
            <button class="btn btn-sm ${i === currentPage ? 'btn-primary' : 'btn-outline-primary'} mx-1" data-page="${i}">
                ${i}
            </button>
        `;
      }

      buttons += `
        <button class="btn btn-sm btn-outline-secondary mx-1" data-page="${currentPage + 1}" ${currentPage === totalPages ? 'disabled' : ''}>
            Next
        </button>
    `;

      paginationEl.html(buttons);

      paginationEl.find('button').off('click').on('click', function () {
         const targetPage = parseInt($(this).data('page'));
         if (!isNaN(targetPage) && targetPage >= 1 && targetPage <= totalPages) {
            currentPage = targetPage;
            renderUserTable();
         }
      });
   };

   (function setupDelegatedEvents() {
      const $assignUserList = $('#assignUserList');

      $assignUserList
         .off('change', '#selectAll')
         .on('change', '#selectAll', function () {
            const isChecked = this.checked;
            const $boxes = $assignUserList.find('.user-checkbox');

            $boxes.each(function () {
               this.checked = isChecked;
               const id = this.value;
               if (isChecked) {
                  selectedUserIds.add(id);
               } else {
                  selectedUserIds.delete(id);
               }
            });

            syncSelectAllHeader();
         });

      $assignUserList
         .off('change', '.user-checkbox')
         .on('change', '.user-checkbox', function () {
            const id = this.value;
            if (this.checked) {
               selectedUserIds.add(id);
            } else {
               selectedUserIds.delete(id);
            }

            syncSelectAllHeader();
         });
   })();

   function syncSelectAllHeader() {
      const selectAll = document.querySelector('#assignUserList #selectAll');
      if (!selectAll) return;

      const boxes = Array.from(document.querySelectorAll('#assignUserList .user-checkbox'));
      const any = boxes.length > 0;
      const all = any && boxes.every(cb => cb.checked);
      const some = any && boxes.some(cb => cb.checked);

      selectAll.checked = all;
      selectAll.indeterminate = !all && some;
      selectAll.disabled = !any;
   }

   $('#assignUserSearch').off('input').on('input', function () {
      const query = $(this).val().toLowerCase();
      filteredUserList = originalUserList.filter(user =>
         user.name.toLowerCase().includes(query)
      );
      currentPage = 1;
      renderUserTable();
   });

   $('#confirmAssignUsers').off('click').on('click', () => {
      const $btn = $('#confirmAssignUsers');
      $btn.prop('disabled', true);

      if (!selectedGroupId) {
         showToast(window.t("usergroup.no_group_selected"), 'danger');
         $btn.prop('disabled', false);
         return;
      }

      const finalIds = Array.from(selectedUserIds).map(String);
      const originalAssignedIds = originalUserList
         .filter(u => u.assigned)
         .map(u => String(u.user_id));

      const addUserIds = finalIds.filter(id => !originalAssignedIds.includes(id));
      const removeUserIds = originalAssignedIds.filter(id => !finalIds.includes(id));

      if (addUserIds.length === 0 && removeUserIds.length === 0) {
         showToast(window.t("usergroup.no_changes_detected"), 'info');
         $btn.prop('disabled', false);
         return;
      }

      Swal.fire({
         title: `${window.t("usergroup.update_group_members?")}`,
         text: `${window.t("usergroup.will_assign")} ${addUserIds.length} ${window.t("usergroup.and_unassign")} ${removeUserIds.length} ${window.t("usergroup.and_um")}`,
         icon: 'question',
         showCancelButton: true,
         confirmButtonColor: '#3085d6',
         cancelButtonColor: '#d33',
         confirmButtonText: `${window.t("usergroup.yes")}`,
         cancelButtonText: `${window.t("usergroup.cancel")}`
      }).then((result) => {
         if (result.isConfirmed) {
            $.ajax({
               url: `/user-mgmt/api/groups/${selectedGroupId}/users`,
               method: 'POST',
               contentType: 'application/json',
               data: JSON.stringify({addUserIds, removeUserIds}),
               success: () => {
                  showToast(`${window.t("usergroup.group_members_updated")}`, 'success');

                  const modalEl = document.getElementById('assignUsersModal');
                  modalEl.addEventListener('hidden.bs.modal', function handler() {
                     modalEl.removeEventListener('hidden.bs.modal', handler);
                     if (window.groupTable) {
                        window.groupTable.replaceData();
                     }
                     $btn.prop('disabled', false);
                  });

                  const modalInstance = bootstrap.Modal.getInstance(modalEl)
                     || new bootstrap.Modal(modalEl, {
                        backdrop: 'static',
                        keyboard: false
                     });

                  if (window.groupTable) {
                     window.groupTable.setSort([{column: "name_e", dir: "asc"}]);
                  }

                  modalInstance.hide();
               },
               error: () => {
                  showToast(`${window.t("usergroup.failed_to_update_group_members")}`, 'danger');
                  $btn.prop('disabled', false);
               }
            });
         } else {
            $btn.prop('disabled', false);
         }
      });
   });

   const showToast = (message, type = 'info') => {
      const toast = $(`
        <div class="toast align-items-center text-white bg-${type} border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">${message}</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        </div>
    `);
      $('#toastContainer').append(toast);
      const bsToast = new bootstrap.Toast(toast[0], {delay: 5000});
      bsToast.show();
      setTimeout(() => toast.remove(), 5500);
   };

   document.addEventListener("click", (e) => {
      if (e.target.classList.contains("assign-users")) {
         const groupId = e.target.dataset.groupId;
         openAssignUsersModal(groupId);
      }
   });
   // ========== ASSIGN USERS MODAL ENDED ==========

   initGroupTable();
});
//--- END ---

//--- FILE: mgmt_userperm.js ---

document.addEventListener("DOMContentLoaded", async () => {

   const createTabulatorTable = (el, config) => new Tabulator(el, config);

   // ========== PERMISSION TABLE ==========

   window.initPermissionTable = async () => {
      const el = document.getElementById("permissionTable");
      if (!el) return;

      const res = await fetch("/user-mgmt/api/permissions");
      const data = await res.json();
      const originalData = JSON.parse(JSON.stringify(data));
      const roles = Object.keys(data[0] || {}).filter(k => k !== "id" && k !== "feature");

      const createRoleFormatter = (limit = 14) => cell => {
         const icon = document.createElement("span");
         const value = cell.getValue();
         icon.textContent = value ? "" : "";
         icon.style.color = value ? "#00a3ad" : "crimson";
         icon.style.cursor = "pointer";

         icon.addEventListener("click", e => {
            e.stopPropagation();
            const row = cell.getRow();
            if (row.getIndex() <= limit) return;

            const current = cell.getValue();
            const newVal = !current;
            cell.setValue(newVal);
            icon.textContent = newVal ? "" : "";
            icon.style.color = newVal ? "#00a3ad" : "crimson";
            row.getElement().classList.add("modified-row");
         });

         return icon;
      };

      const formatRow = (row, limit = 14) => {
         const rowEl = row.getElement();
         const index = row.getIndex();
         rowEl.classList.add(index <= limit ? "protected-row" : "editable-row");

         if (index <= limit) {
            roles.forEach(role => {
               const cell = row.getCell(role);
               if (cell) {
                  Object.assign(cell.getElement().style, {
                     backgroundColor: "transparent",
                     color: "#aaa",
                     cursor: "not-allowed",
                     opacity: "0.6",
                     pointerEvents: "none"
                  });
               }
            });
            rowEl.title = window.t("userperm.editing_disabled_for_protected_row");
         }
      };

      const table = createTabulatorTable(el, {
         data,
         columns: [
            {
               title: window.t("userperm.feature"),
               field: "feature",
               frozen: true,
               headerSort: false,
               resizable: false
            },
            ...roles.map(role => ({
               title: role,
               field: role,
               hozAlign: "center",
               headerVertical: true,
               editor: false,
               headerSort: false,
               formatter: createRoleFormatter()
            }))
         ],
         layout: "fitDataStretch",
         height: "660",
         frozenRows: 14,
         pagination: false,
         rowFormatter: row => formatRow(row)
      });

      const saveBtn = document.getElementById("saveBtn");
      saveBtn?.addEventListener("click", async () => {
         const text = saveBtn.querySelector("span");
         saveBtn.classList.add("disabled");
         if (text) text.textContent = "Saving...";
         try {
            const res = await fetch("/user-mgmt/api/permissions", {
               method: "POST",
               headers: {"Content-Type": "application/json"},
               body: JSON.stringify(table.getData())
            });
            if (!res.ok) {
               const errorMsg = await res.text();
               console.error("Update failed:", errorMsg);
               alert(window.t("userperm.failed_to_update_user"));
               return;
            }
            Swal.fire({
               title: window.t("userperm.updated"),
               text: window.t("userperm.permission_matrix_saved"),
               icon: "success"
            });
         } catch (err) {
            Swal.fire({title: window.t("userperm.save_failed"), text: err.message, icon: "error"});
         } finally {
            if (text) text.textContent = window.t("userperm.save");
            saveBtn.classList.remove("disabled");
         }
      });

      const resetBtn = document.getElementById("resetBtn");
      resetBtn?.addEventListener("click", () => {
         const freshData = JSON.parse(JSON.stringify(originalData));
         try {
            table.setData(freshData).then(() => {
               table.getRows().forEach(row => {
                  row.getElement().classList.remove("modified-row", "editable-row", "protected-row");
                  formatRow(row);
                  row.getCells().forEach(cell => {
                     const col = cell.getColumn();
                     const formatter = col.getDefinition().formatter;
                     if (typeof formatter === "function") {
                        const el = formatter(cell);
                        const cellEl = cell.getElement();
                        if (cellEl && el instanceof HTMLElement) {
                           cellEl.innerHTML = "";
                           cellEl.appendChild(el);
                        }
                     }
                  });
               });
               Swal.fire({title: window.t("userperm.changes_cleared"), icon: "success"});
            });
         } catch (err) {
            console.error("Reset failed:", err);
         }
      });
   };

   if (typeof initPermissionTable === "function") {
      initPermissionTable();
   } else {
      console.error("initPermissionTable is not defined");
   }

})
//--- END ---

//--- FILE: view_lib.js ---

(() => {
   // --- Small helpers -------------------------------------------------------
   const safeFetchJson = async (url, opts = {}) => {
      const res = await fetch(url, opts);
      if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
      return res.json().catch(() => null);
   };

   const debounce = (fn, ms = 100) => {
      let t = null;
      return (...args) => {
         clearTimeout(t);
         t = setTimeout(() => fn(...args), ms);
      };
   };

   const safeFeatherReplace = (typeof window.feather === 'object' && typeof window.feather.replace === 'function')
      ? debounce(() => window.feather.replace(), 40)
      : () => {
      };

   // --- viewLib.openPreview patch (idempotent) -----------------------------
   if (window.viewLib && typeof window.viewLib.openPreview === 'function' && !window.__viewLibOpenPreviewPatched) {
      const orig = window.viewLib.openPreview.bind(window.viewLib);
      window.viewLib.openPreview = async (contentId) => {
         try {
            const json = await safeFetchJson(`/content-mgmt/api/contents/${encodeURIComponent(contentId)}`, {credentials: 'include'});
            const data = (json && json.data) ? json.data : {};
            const type = (data.type || '').toString().toLowerCase();

            if (type === 'pdf' && window.Mgmt?.pdfPreview) return window.Mgmt.pdfPreview.open(contentId);
            if (type.startsWith('video') && window.Mgmt?.videoPreview) return window.Mgmt.videoPreview.open(contentId);
            if (window.Mgmt?.htmlPreview) return window.Mgmt.htmlPreview.open(contentId);

            return orig(contentId);
         } catch (err) {
            return Promise.reject(err);
         }
      };
      window.__viewLibOpenPreviewPatched = true;
   }

   // --- Module state -------------------------------------------------------
   const STATE = {
      TABLE_SELECTOR: '#libTable',
      CUSTOM_SEARCH_ID: 'libTable_custom_search',
      CUSTOM_FILTER_FLAG: '__viewLibCustomFilterRegistered'
   };

   // --- Build custom pagination (kept small and deterministic) -------------
   const buildPagination = (api) => {
      const pageInfo = api.page.info();
      let $paginate = window.jQuery('#custom-pagination');
      if (!$paginate.length) {
         $paginate = window.jQuery('<div id="custom-pagination" class="mt--40"></div>');
         window.jQuery(api.table().node()).after($paginate);
      }
      $paginate.empty();

      const $ul = window.jQuery('<ul class="rbt-pagination"></ul>');

      const $prev = window.jQuery('<li><a href="#" aria-label="Previous"><i class="feather-chevron-left"></i></a></li>');
      if (pageInfo.page === 0) $prev.addClass('disabled');
      $prev.on('click', (e) => {
         e.preventDefault();
         if (pageInfo.page > 0) api.page('previous').draw('page');
      });
      $ul.append($prev);

      for (let i = 0; i < pageInfo.pages; i++) {
         const $li = window.jQuery(`<li><a href="#">${i + 1}</a></li>`);
         if (i === pageInfo.page) $li.addClass('active');
         $li.on('click', (e) => {
            e.preventDefault();
            api.page(i).draw('page');
         });
         $ul.append($li);
      }

      const $next = window.jQuery('<li><a href="#" aria-label="Next"><i class="feather-chevron-right"></i></a></li>');
      if (pageInfo.page >= pageInfo.pages - 1) $next.addClass('disabled');
      $next.on('click', (e) => {
         e.preventDefault();
         if (pageInfo.page < pageInfo.pages - 1) api.page('next').draw('page');
      });
      $ul.append($next);

      $paginate.append(window.jQuery('<nav></nav>').append($ul));
   };

   // --- Main init ----------------------------------------------------------
   const init = () => {
      const $ = window.jQuery;
      if (!($ && $.fn && $.fn.DataTable)) return;

      const tableEl = document.querySelector(STATE.TABLE_SELECTOR);
      if (!tableEl) return;

      const $table = $(tableEl);

      // Guarded DataTable init: reuse existing instance if present
      let dt;
      if ($.fn.dataTable.isDataTable(STATE.TABLE_SELECTOR)) {
         dt = $table.DataTable();
      } else {
         dt = $table.DataTable({
            pageLength: 5,
            order: [[0, 'desc']],
            autoWidth: false,
            scrollX: false,
            language: {
               search: ' Filter:',
               info: 'Showing _START_ to _END_ of _TOTAL_ entries'
            },
            dom: '<"rbt-search-wrapper"f><"row"<"col-lg-12"t>>',
            initComplete: function () {
               // If DataTables created the filter, tidy it without cloning
               try {
                  const $filter = $('#libTable_filter');
                  const $label = $filter.children('label');
                  const $input = $label.find('input[type="search"]');
                  if ($input.length) {
                     // Remove textual label nodes only, keep the input node intact
                     $label.contents().filter(function () {
                        return this.nodeType === 3 && this.textContent.trim().length > 0;
                     }).remove();

                     // Insert a visual wrapper if not present (safe: does not clone input)
                     if (!$filter.find('.search-bar').length) {
                        $input.attr('placeholder', getPlaceholderText());
                        $filter.prepend('<div class="search-bar" role="search" aria-label="Table search"><i class="feather-search" aria-hidden="true"></i></div>');
                        $filter.find('.search-bar').append($input);
                     }
                  }
               } catch (e) {
                  // swallow  noncritical
               }
               safeFeatherReplace();
            },
            drawCallback: function () {
               const api = this.api();
               buildPagination(api);
               safeFeatherReplace();
            }
         });
      }

      // --- Custom filtering via ext.search (idempotent registration) --------
      // Normalizer
      const norm = (v) => (v === null || v === undefined) ? '' : String(v).trim().toLowerCase();

      // Example selectors (update to actual control IDs if different)
      const SELECTOR_CUSTOM_TEXT = '#custom-filter-input-1';
      const SELECTOR_CUSTOM_SELECT = '#custom-filter-select-2';

      const customFilterFn = function (settings, rowData /*, rowIndex */) {
         if (settings.nTable !== dt.table().node()) return true; // scope to this table

         const $text = $(SELECTOR_CUSTOM_TEXT);
         const $select = $(SELECTOR_CUSTOM_SELECT);
         if (!$text.length && !$select.length) return true; // no controls => no extra filter

         const fText = norm($text.val());
         const fSelect = norm($select.val());

         const col1 = norm(rowData[1] || '');
         const col2 = norm(rowData[2] || '');

         if (fText && !col1.includes(fText)) return false;
         if (fSelect && fSelect !== '' && col2 !== fSelect) return false;
         return true;
      };

      if (!window[STATE.CUSTOM_FILTER_FLAG]) {
         $.fn.dataTable.ext.search.push(customFilterFn);
         window[STATE.CUSTOM_FILTER_FLAG] = true;
      }

      const redraw = debounce(() => {
         if (dt) dt.draw(false);
      }, 120);
      if ($(SELECTOR_CUSTOM_TEXT).length) $(SELECTOR_CUSTOM_TEXT).on('keyup change', redraw);
      if ($(SELECTOR_CUSTOM_SELECT).length) $(SELECTOR_CUSTOM_SELECT).on('change', redraw);

      // --- Preview handlers (namespaced) ------------------------------------
      $table.off('click.viewlib').on('click.viewlib', '.type-icon', function () {
         const $el = $(this);
         const contentId = $el.data('content-id');
         if (!contentId) return;

         if (window.viewLib && typeof window.viewLib.openPreview === 'function') {
            window.viewLib.openPreview(contentId).catch(() => {
            });
         } else if (typeof window.openViewModal === 'function') {
            window.openViewModal(contentId);
         }
      });

      $table.off('keydown.viewlib').on('keydown.viewlib', '.type-icon', function (e) {
         if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            $(this).trigger('click');
         }
      });

      // --- Stable custom search fallback (when built-in filter is absent) ---
      // Create only once, and bind to dt.search()
      if (!document.getElementById(STATE.CUSTOM_SEARCH_ID)) {
         // If DataTables built-in filter exists and contains an input, prefer styling it (do nothing)
         const builtInFilter = document.querySelector('#libTable_filter input[type="search"]');
         if (!builtInFilter) {
            const $wrap = $(`
          <div id="${STATE.CUSTOM_SEARCH_ID}" style="display:flex;justify-content:center;margin:32px 0 8px;">
            <div class="search-bar" style="position:relative;width:420px;max-width:92%;box-sizing:border-box;">
              <i class="feather-search" aria-hidden="true" style="position:absolute;left:14px;top:50%;transform:translateY(-50%);color:#6b6f76;pointer-events:none;font-size:16px;"></i>
              <input type="search" aria-label="Table search" placeholder="Search" style="width:100%;padding:10px 16px 10px 44px;border-radius:999px;border:0;background:rgba(240,240,240,0.65);box-shadow:0 6px 18px rgba(24,39,75,0.06);outline:none;font-size:15px;font-weight:500;color:#111;" />
            </div>
          </div>
        `);
            if (document.getElementById('libTable_search_placeholder')) {
               // $wrap is a jQuery object here; use DOM node for native insertion
               document.getElementById('libTable_search_placeholder').before($wrap[0] || $wrap);
            } else {
               $table.before($wrap);
            }

            const $input = $wrap.find('input[type="search"]');
            const doSearch = debounce(() => dt.search($input.val()).draw(), 120);
            $input.on('input change', doSearch);
            if (window.feather) feather.replace();
         }
      }

      // --- Cleanup helper (exposed) ------------------------------------------
      window.viewLibFilters = {
         unregister: () => {
            // unregister custom ext.search (if registered)
            if (window[STATE.CUSTOM_FILTER_FLAG]) {
               $.fn.dataTable.ext.search = $.fn.dataTable.ext.search.filter(fn => fn !== customFilterFn);
               window[STATE.CUSTOM_FILTER_FLAG] = false;
            }
            // remove custom search UI
            const el = document.getElementById(STATE.CUSTOM_SEARCH_ID);
            if (el) el.remove();
            // remove event handlers
            $table.off('.viewlib');
            try { $('#custom-pagination').remove(); } catch (e) {}
         }
      };
   }; // end init

   // Run init on DOMContentLoaded
   if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
   } else {
      init();
   }
   // ---------- ensure-single-search.js (idempotent) ----------
   (() => {
      const $ = window.jQuery;
      if (!($ && $.fn && $.fn.DataTable)) {
         console.warn('[search-fix] jQuery/DataTables missing');
         return;
      }

      const log = (...args) => {
         try { console.info('[search-fix]', ...args); } catch (e) {}
      };
      const TABLE_SEL = '#libTable';
      const CUSTOM_ID = 'libTable_custom_search';

      // Helpers
      const findBuiltInInput = () => {
         // common places and fallbacks
         let $input = $('#dt-search-0');
         if (!$input.length) $input = $('#libTable_filter').find('input[type="search"]');
         if (!$input.length) $input = $('#rbt-search-wrapper').find('input[type="search"]');
         if (!$input.length) $input = $('#libTable_wrapper').find('input[type="search"][aria-controls="libTable"]');
         if (!$input.length) $input = $('input[type="search"]').filter((i, el) => el.closest && el.closest('#libTable_wrapper'));
         return $input;
      };

      const stripLabelTextNodes = ($el) => {
         if (!$el || !$el.length) return;
         $el.contents().filter(function () {
            return this.nodeType === 3 && this.textContent.trim().length > 0;
         }).remove();
      };

      const getPlaceholderText = () => {
         const el = document.getElementById('libTable_search_placeholder');
         return (el && el.dataset && el.dataset.searchPlaceholder) ? String(el.dataset.searchPlaceholder) : 'Search';
      };

      const wrapExistingInput = ($input, $targetContainer) => {
         if (!$input.length) return false;
         const $container = ($targetContainer && $targetContainer.length) ? $targetContainer : $input.parent();
         if ($container.find('.search-bar').length) {
            log('built-in already wrapped');
            return true;
         }
         $input.attr('placeholder', getPlaceholderText());
         const $bar = $('<div class="search-bar" role="search" aria-label="Table search"><i class="feather-search" aria-hidden="true"></i></div>');
         $container.prepend($bar);
         $bar.append($input); // move node; do NOT clone
         if (window.feather) try { window.feather.replace(); } catch (e) {}
         log('moved built-in input into .search-bar');
         return true;
      };

      const removeCustomSearch = () => {
         const el = document.getElementById(CUSTOM_ID);
         if (el) {
            el.remove();
            log('removed custom fallback search');
            return true;
         }
         return false;
      };

      const createCustomSearch = (dt) => {
         if (document.getElementById(CUSTOM_ID)) return document.getElementById(CUSTOM_ID);
         const $wrap = $(`
      <div id="${CUSTOM_ID}" style="display:flex;justify-content:center;margin:32px 0 8px;">
        <div class="search-bar" style="position:relative;width:420px;max-width:92%;box-sizing:border-box;">
          <i class="feather-search" aria-hidden="true" style="position:absolute;left:14px;top:50%;transform:translateY(-50%);color:#6b6f76;pointer-events:none;font-size:16px;"></i>
          <input type="search" aria-label="Table search" placeholder="Search" style="width:100%;padding:10px 16px 10px 44px;border-radius:999px;border:0;background:rgba(240,240,240,0.65);box-shadow:0 6px 18px rgba(24,39,75,0.06);outline:none;font-size:15px;font-weight:500;color:#111;" />
        </div>
      </div>
    `);
         if (document.getElementById('libTable_search_placeholder')) {
            document.getElementById('libTable_search_placeholder').before($wrap[0] || $wrap);
         } else {
            $(TABLE_SEL).before($wrap);
         }

         const placeholderText = getPlaceholderText();
         $wrap.find('input[type="search"]').attr('placeholder', placeholderText);

         const $input = $wrap.find('input[type="search"]');
         const debounce = (fn, ms = 120) => {
            let t = null;
            return (...a) => {
               clearTimeout(t);
               t = setTimeout(() => fn(...a), ms);
            };
         };
         const doSearch = debounce(() => {
            const dt = $.fn.dataTable.isDataTable(TABLE_SEL) ? $(TABLE_SEL).DataTable() : null;
            if (dt) dt.search($input.val()).draw();
         }, 120);
         $input.on('input change', doSearch);
         if (window.feather) try { window.feather.replace(); } catch (e) {}
         log('created custom fallback search');
         return $wrap[0];
      };

      const syncInputs = ($a, $b) => {
         if (!$a.length || !$b.length) return;
         $a.off('.searchSync').on('input.searchSync', () => $b.val($a.val()));
         $b.off('.searchSync').on('input.searchSync', () => {
            $a.val($b.val());
            const dt = $.fn.dataTable.isDataTable(TABLE_SEL) ? $(TABLE_SEL).DataTable() : null;
            if (dt) dt.search($b.val()).draw();
         });
         log('synchronized inputs');
      };

      // Try immediate fix
      const attempt = () => {
         const dt = $.fn.dataTable.isDataTable(TABLE_SEL) ? $(TABLE_SEL).DataTable() : null;
         const $built = findBuiltInInput();
         log('attempting: built-in found?', !!$built.length, 'dt?', !!dt);
         if ($built.length) {
            // if input exists, move & style it and remove custom fallback
            const $label = $built.closest('label');
            stripLabelTextNodes($label);
            const parent = ($label && $label.length) ? $label.parent() : $('#rbt-search-wrapper, #libTable_filter').first();
            if (wrapExistingInput($built, parent)) {
               removeCustomSearch();
               return true;
            }
         } else {
            // built-in not found: ensure fallback exists and bound
            createCustomSearch(dt);
            return false;
         }
         return false;
      };

      if (attempt()) return;

      // Observe for later creation (longer timeout)
      const observer = new MutationObserver((mutations, obs) => {
         try {
            const $built = findBuiltInInput();
            if ($built.length) {
               attempt();
               obs.disconnect();
               log('observer: handled built-in when it appeared');
            }
         } catch (e) {
            console.warn('[search-fix] observer error', e);
         }
      });
      observer.observe(document.body, {childList: true, subtree: true});

      // safety timeout: ensure fallback and hide any late-built-in if nothing fixed
      setTimeout(() => {
         observer.disconnect();
         const dt = $.fn.dataTable.isDataTable(TABLE_SEL) ? $(TABLE_SEL).DataTable() : null;
         createCustomSearch(dt);
         // hide built-in containers if they exist (non-destructive hide)
         $('#libTable_filter, #rbt-search-wrapper, #libTable_wrapper .dt-search').hide();
         log('safety timeout: created fallback and hid built-in containers');
      }, 50);
   })();

   // download helper: event-delegated, works for many buttons
   (function () {
      const parseFilenameFromContentDisposition = (cd) => {
         if (!cd) return null;
         // RFC5987 encoded filename* or basic filename= fallback
         const fnStar = /filename\\*=UTF-8''([^;\\n]+)/i.exec(cd);
         if (fnStar && fnStar[1]) return decodeURIComponent(fnStar[1]);
         const fn = /filename="?([^";]+)"?/i.exec(cd);
         if (fn && fn[1]) return fn[1];
         return null;
      };

      const downloadBlob = (blob, filename) => {
         const url = URL.createObjectURL(blob);
         const a = document.createElement('a');
         a.href = url;
         a.download = filename || '';
         document.body.appendChild(a);
         a.click();
         a.remove();
         setTimeout(() => URL.revokeObjectURL(url), 2000);
      };

      const handleServerError = async (resp) => {
         let msg = 'Download failed';
         try {
            const ct = resp.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
               const j = await resp.json().catch(() => null);
               if (j && j.error) msg = j.error;
               else if (j && j.message) msg = j.message;
               else msg = JSON.stringify(j);
            } else {
               const txt = await resp.text().catch(() => null);
               if (txt) msg = txt;
            }
         } catch (e) { /* ignore */ }
         return msg;
      };

      const startDownload = async (contentId) => {
         // disable action quickly to avoid double clicks
         const endpoint = `/content-mgmt/api/contents/${encodeURIComponent(contentId)}/download`;
         try {
            const resp = await fetch(endpoint, {
               method: 'POST',
               credentials: 'include',
               headers: {
                  'Accept': 'application/octet-stream' // prefer binary
                  // If you use CSRF tokens, include them here, e.g. 'x-csrf-token': window.__CSRF
               }
            });

            if (!resp.ok) {
               const errMsg = await handleServerError(resp);
               // minimal user feedback  replace with your UI toast if available
               window.alert(errMsg || 'Download failed');
               return;
            }

            const contentDisposition = resp.headers.get('content-disposition') || '';
            const cdFilename = parseFilenameFromContentDisposition(contentDisposition);
            let filename = cdFilename || `file-${contentId}`;

            // fallback to orig_fname exposed on the page? (avoid leaking server path)
            // const pageElem = document.querySelector(`[data-content-id="${contentId}"]`);
            // if (!cdFilename && pageElem && pageElem.dataset && pageElem.dataset.origName) filename = pageElem.dataset.origName;

            const blob = await resp.blob();
            // if response is an HTML error page disguised as 200, detect small size and text content-type
            const ct = resp.headers.get('content-type') || '';
            if (ct.includes('text/') && blob.size < 4096) {
               const text = await blob.text().catch(() => null);
               // try JSON parse
               try {
                  const j = text ? JSON.parse(text) : null;
                  if (j && j.error) {
                     window.alert(j.error);
                     return;
                  }
               } catch {}
            }

            downloadBlob(blob, filename);
         } catch (err) {
            console.error('download error', err);
            window.alert('Download failed');
         }
      };

      // Event delegation: listen on document for clicks on .btn-download
      document.addEventListener('click', (ev) => {
         const target = ev.target;
         if (!target) return;
         const el = target.closest && target.closest('.btn-download');
         if (!el) return;

         ev.preventDefault();
         const contentId = el.getAttribute('data-content-id');
         if (!contentId) {
            console.warn('download clicked but no content id');
            return;
         }

         // visual feedback: disable element briefly
         const prevPointer = el.style.pointerEvents;
         el.style.pointerEvents = 'none';
         startDownload(contentId).finally(() => {
            el.style.pointerEvents = prevPointer || '';
         });
      });
   })();

})();
//--- END ---

//--- EOF ---
